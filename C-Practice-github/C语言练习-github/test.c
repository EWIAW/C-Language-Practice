////////////////////////////#include<stdio.h>
////////////////////////////
////////////////////////////int main()
////////////////////////////{
////////////////////////////	printf("hello world\n");
////////////////////////////	return 0;
////////////////////////////}
//////////////////////////
//////////////////////////
////////////////////////////#include<stdio.h>
////////////////////////////
////////////////////////////int Two(int n)
////////////////////////////{
////////////////////////////	if (n > 1)//nҪ����������Ƶ�Сһλ����������ƣ���n>1���������ƣ���n>5
////////////////////////////	{
////////////////////////////		Two(n / 2);
////////////////////////////	}
////////////////////////////	printf("%d", n % 2);
////////////////////////////}
////////////////////////////
////////////////////////////int main()
////////////////////////////{
////////////////////////////	int input;
////////////////////////////	scanf("%d", &input);
////////////////////////////	Two(input);
////////////////////////////	return 0;
////////////////////////////}
//////////////////////////
//////////////////////////
////////////////////////////#include<stdio.h>
////////////////////////////int main()
////////////////////////////{
////////////////////////////	int a[10], i, t, j;
////////////////////////////	printf("������ʮ������");
////////////////////////////	for (i = 1; i <= 10; i++)
////////////////////////////		scanf("%d", &a[i]);
////////////////////////////	printf("\n");
////////////////////////////	for (j = 1; j < 10; j++)
////////////////////////////		for (i = 1; i < 11 - j; i++)
////////////////////////////			if (a[i] > a[i + 1])
////////////////////////////			{
////////////////////////////				t = a[i]; a[i] = a[i + 1]; a[i + 1] = t;
////////////////////////////			}
////////////////////////////	printf("�����Ϊ");
////////////////////////////	for (i = 1; i <= 10; i++)
////////////////////////////		printf("%d ", a[i]);
////////////////////////////	printf("\n");
////////////////////////////	return 0;
////////////////////////////}
//////////////////////////
//////////////////////////
//////////////////////////
////////////////////////////#include<stdio.h>
////////////////////////////#include<stdlib.h>
////////////////////////////int main()
////////////////////////////{
////////////////////////////	int N = 50;
////////////////////////////	int a = 1;
////////////////////////////	int* tmp = (int*)malloc(sizeof(int) * N);
////////////////////////////	for (int i = 0; i < 50; i++)
////////////////////////////	{
////////////////////////////		tmp[i] = a;
////////////////////////////		a += 2;
////////////////////////////	}
////////////////////////////	for (int i = 0; i < N; i++)
////////////////////////////	{
////////////////////////////		printf("%d ", tmp[i]);
////////////////////////////	}
////////////////////////////
////////////////////////////	printf("\n");
////////////////////////////
////////////////////////////	int check;
////////////////////////////	scanf("%d", &check);
////////////////////////////
////////////////////////////	int l = 0;
////////////////////////////	int r = N - 1;
////////////////////////////
////////////////////////////	while (l<r)
////////////////////////////	{
////////////////////////////		int mid = r / 2;
////////////////////////////		if (check > tmp[mid])
////////////////////////////		{
////////////////////////////			l = mid;
////////////////////////////		}
////////////////////////////		else
////////////////////////////		{
////////////////////////////			r = mid;
////////////////////////////		}
////////////////////////////		if (check == tmp[mid])
////////////////////////////		{
////////////////////////////			printf("�ҵ���\n");
////////////////////////////			break;
////////////////////////////		}
////////////////////////////	}
////////////////////////////	
////////////////////////////
////////////////////////////	return 0;
////////////////////////////}
//////////////////////////
//////////////////////////
//////////////////////////
////////////////////////////#include<stdio.h>
////////////////////////////#include<string.h>
////////////////////////////
////////////////////////////int main()
////////////////////////////{
////////////////////////////	char arr[20];
////////////////////////////	gets(arr);
////////////////////////////	printf("%d", strlen(arr));
////////////////////////////	return 0;
////////////////////////////}
//////////////////////////
//////////////////////////
//////////////////////////
////////////////////////////#include<stdio.h>
////////////////////////////
////////////////////////////void check(int *a, int sz)
////////////////////////////{
////////////////////////////	int tmp1 = 0;
////////////////////////////	int tmp2 = 0;
////////////////////////////	int ret = 0;
////////////////////////////	for (int i = 0; i < sz; i++)
////////////////////////////	{
////////////////////////////		ret = ret ^ a[i];
////////////////////////////	}
////////////////////////////	int b;
////////////////////////////	for (int i = 0; i < 32; i++)
////////////////////////////	{
////////////////////////////		if ((ret >> i) & 1 == 1)
////////////////////////////		{
////////////////////////////			b = i;
////////////////////////////			break;
////////////////////////////
////////////////////////////		}
////////////////////////////	}
////////////////////////////	for (int i = 0; i < sz; i++)
////////////////////////////	{
////////////////////////////		if ((a[i] >> b) & 1 == 1)
////////////////////////////		{
////////////////////////////			tmp1=tmp1^ a[i];
////////////////////////////		}
////////////////////////////		else
////////////////////////////		{
////////////////////////////			tmp2 = tmp2 ^ a[i];
////////////////////////////		}
////////////////////////////	}
////////////////////////////	printf("%d %d", tmp1, tmp2);
////////////////////////////}
////////////////////////////
////////////////////////////int main()
////////////////////////////{
////////////////////////////	int arr[10] = { 1,2,3,4,5,6,1,2,3,4 };
////////////////////////////	int sz = sizeof(arr) / sizeof(int);
////////////////////////////	check(arr, sz);
////////////////////////////	return 0;
////////////////////////////}
//////////////////////////
//////////////////////////
//////////////////////////
////////////////////////////#include<stdio.h>
////////////////////////////#include<stdlib.h>
////////////////////////////void rotate(int* nums, int numsSize, int k)
////////////////////////////{
////////////////////////////    int* arr = (int*)malloc(sizeof(int) * numsSize);
////////////////////////////    int i = numsSize - k;
////////////////////////////    for (int a = 0; a < numsSize; a++, i++)
////////////////////////////    {
////////////////////////////        if (i == numsSize)
////////////////////////////        {
////////////////////////////            i = 0;
////////////////////////////        }
////////////////////////////        arr[a] = nums[i];
////////////////////////////    }
////////////////////////////    for (int i = 0; i < numsSize; i++)
////////////////////////////    {
////////////////////////////        printf("%d ", arr[i]);
////////////////////////////    }
////////////////////////////}
////////////////////////////int main()
////////////////////////////{
////////////////////////////    int arr[] = { 1,2,3,4,5,6,7 };
////////////////////////////    int sz = sizeof(arr) / sizeof(int);
////////////////////////////    rotate(arr, sz, 3);
////////////////////////////}
//////////////////////////
//////////////////////////
//////////////////////////
////////////////////////////#include<stdio.h>
////////////////////////////#include<malloc.h>
////////////////////////////void rotate(int* nums, int numsSize, int k)
////////////////////////////{
////////////////////////////    int* a = (int*)malloc(sizeof(int) * numsSize);
////////////////////////////    int i = numsSize - k;
////////////////////////////    for (int j = 0; j < numsSize; j++, i++)
////////////////////////////    {
////////////////////////////        if (i == numsSize)
////////////////////////////        {
////////////////////////////            i = 0;
////////////////////////////        }
////////////////////////////        a[j] = nums[i];
////////////////////////////    }
////////////////////////////    nums = a;
////////////////////////////    for (int i = 0; i < numsSize; i++)
////////////////////////////    {
////////////////////////////        printf("%d ", nums[i]);
////////////////////////////    }
////////////////////////////}
////////////////////////////int main()
////////////////////////////{
////////////////////////////    int nums[7] = { 1,2,3,4,5,6,7 };
////////////////////////////    int k = 3;
////////////////////////////    int sz = sizeof(nums) / sizeof(int);
////////////////////////////    rotate(nums, sz, k);
////////////////////////////
////////////////////////////    return 0;
////////////////////////////}
//////////////////////////
//////////////////////////
////////////////////////////#pragma pack(2)
////////////////////////////#include<stdio.h>
////////////////////////////
////////////////////////////struct str1
////////////////////////////{
////////////////////////////    char i;
////////////////////////////    int j;
////////////////////////////    char k;
////////////////////////////};
////////////////////////////struct str2
////////////////////////////{
////////////////////////////    char a;
////////////////////////////    struct str1 s1;
////////////////////////////    double b;
////////////////////////////};
////////////////////////////int main()
////////////////////////////{
////////////////////////////    printf("%d\n", sizeof(struct str1));
////////////////////////////    printf("%d\n", sizeof(struct str2));
////////////////////////////    return 0;
////////////////////////////}
//////////////////////////
//////////////////////////
////////////////////////////struct str1
////////////////////////////{
////////////////////////////	int i;
////////////////////////////	int j;
////////////////////////////};
////////////////////////////struct str2
////////////////////////////{
////////////////////////////	char a;
////////////////////////////	struct str1 b;
////////////////////////////	int c;
////////////////////////////};
////////////////////////////int main()
////////////////////////////{
////////////////////////////	printf("%d", sizeof(struct str2));
////////////////////////////	return 0;
////////////////////////////}
//////////////////////////
//////////////////////////
//////////////////////////
////////////////////////////#pragma pack(2)
////////////////////////////#include<stdio.h>
////////////////////////////
////////////////////////////struct str
////////////////////////////{
////////////////////////////	char i;
////////////////////////////	int j;
////////////////////////////};
////////////////////////////
////////////////////////////int main()
////////////////////////////{
////////////////////////////	printf("%d\n", sizeof(struct str));
////////////////////////////	return 0;
////////////////////////////}
//////////////////////////
//////////////////////////
//////////////////////////
////////////////////////////#include<stdio.h>
////////////////////////////
////////////////////////////void GetMemory(char* p)
////////////////////////////{
////////////////////////////	p = (char*)malloc(100);
////////////////////////////}
////////////////////////////void Test(void)
////////////////////////////{
////////////////////////////	char* str = NULL;
////////////////////////////	GetMemory(str);
////////////////////////////	strcpy(str, "hello world");
////////////////////////////	printf(str);
////////////////////////////}
////////////////////////////
////////////////////////////int main()
////////////////////////////{
////////////////////////////	Test();
////////////////////////////	return 0;
////////////////////////////}
//////////////////////////
//////////////////////////
////////////////////////////#include<stdio.h>
////////////////////////////union Un1
////////////////////////////{
////////////////////////////	char c[5];
////////////////////////////	int i;
////////////////////////////};
////////////////////////////union Un2
////////////////////////////{
////////////////////////////	short c[7];
////////////////////////////	int i;
////////////////////////////};
//////////////////////////////��������Ľ����ʲô��
////////////////////////////int main()
////////////////////////////{
////////////////////////////	printf("%d\n", sizeof(union Un1));
////////////////////////////	printf("%d\n", sizeof(union Un2));
////////////////////////////	return 0;
////////////////////////////}
//////////////////////////
//////////////////////////
//////////////////////////
////////////////////////////#include<stdio.h>
////////////////////////////#include<stdlib.h>
////////////////////////////int main()
////////////////////////////{
////////////////////////////	int* p = NULL;
////////////////////////////	*p = 10;
////////////////////////////	return 0;
////////////////////////////}
//////////////////////////
//////////////////////////
////////////////////////////#include<stdio.h>
////////////////////////////
////////////////////////////void move(int* nums, int head, int* numsSize)
////////////////////////////{
////////////////////////////    while (head < (*numsSize))
////////////////////////////    {
////////////////////////////        nums[head] = nums[head + 1];
////////////////////////////        head++;
////////////////////////////    }
////////////////////////////    (*numsSize)--;
////////////////////////////}
////////////////////////////
////////////////////////////int removeDuplicates(int* nums, int numsSize)
////////////////////////////{
////////////////////////////    int i = 1;
////////////////////////////    int tmp = nums[0];
////////////////////////////    while (i < numsSize)
////////////////////////////    {
////////////////////////////        while (nums[i] == tmp)
////////////////////////////        {
////////////////////////////            move(nums, i, &numsSize);
////////////////////////////        }
////////////////////////////        tmp = nums[i];
////////////////////////////        i++;
////////////////////////////    }
////////////////////////////    return numsSize;
////////////////////////////}
////////////////////////////
////////////////////////////int main()
////////////////////////////{
////////////////////////////	int arr[] = { 0,0,1,1,1,2,2,3,3,4 };
////////////////////////////	int sz = sizeof(arr) / sizeof(int);
////////////////////////////    int len=removeDuplicates(arr, sz);
////////////////////////////
////////////////////////////    for (int i = 0; i < len; i++)
////////////////////////////    {
////////////////////////////        printf("%d ", arr[i]);
////////////////////////////    }
////////////////////////////
////////////////////////////	return 0;
////////////////////////////}
//////////////////////////
//////////////////////////
////////////////////////////#include<stdio.h>
////////////////////////////#include<stdlib.h>
////////////////////////////
////////////////////////////void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n)
////////////////////////////{
////////////////////////////    int* arr = (int*)malloc(sizeof(int) * n * m);
////////////////////////////    if (arr == NULL)
////////////////////////////    {
////////////////////////////        printf("����ʧ��\n");
////////////////////////////        exit(-1);
////////////////////////////    }
////////////////////////////    int i = 0;
////////////////////////////    int j = 0;
////////////////////////////    int k = 0;
////////////////////////////    while (i < m && j < n)
////////////////////////////    {
////////////////////////////        if (nums1[i] <= nums2[j])
////////////////////////////        {
////////////////////////////            arr[k] = nums1[i];
////////////////////////////            i++;
////////////////////////////            k++;
////////////////////////////        }
////////////////////////////        else
////////////////////////////        {
////////////////////////////            arr[k] = nums2[j];
////////////////////////////            j++;
////////////////////////////            k++;
////////////////////////////        }
////////////////////////////    }
////////////////////////////    if (i == m)
////////////////////////////    {
////////////////////////////        while (j < n)
////////////////////////////        {
////////////////////////////            arr[k] = nums2[j];
////////////////////////////            k++;
////////////////////////////            j++;
////////////////////////////        }
////////////////////////////    }
////////////////////////////    else
////////////////////////////    {
////////////////////////////        while (i < m)
////////////////////////////        {
////////////////////////////            arr[k] = nums1[i];
////////////////////////////            i++;
////////////////////////////            k++;
////////////////////////////        }
////////////////////////////    }
////////////////////////////    for (int i = 0; i < m + n; i++)
////////////////////////////    {
////////////////////////////        nums1[i] = arr[i];
////////////////////////////    }
////////////////////////////}
////////////////////////////
////////////////////////////int main()
////////////////////////////{
////////////////////////////	int arr1[6] = { 1,2,3 };
////////////////////////////	int arr2[] = { 2,5,6 };
////////////////////////////    int sz1 = sizeof(arr1) / sizeof(int);
////////////////////////////    int sz2 = sizeof(arr2) / sizeof(int);
////////////////////////////    merge(arr1, sz1, 3, arr2, sz2, sz2);
////////////////////////////	return 0;
////////////////////////////}
//////////////////////////
//////////////////////////
////////////////////////////#include<stdio.h>
////////////////////////////#include<stdlib.h>
////////////////////////////
////////////////////////////struct ListNode
////////////////////////////{
////////////////////////////	int val;
////////////////////////////	struct ListNode* next;
////////////////////////////};
////////////////////////////
////////////////////////////struct ListNode* BuySListNode(int x)//�����ڵ�
////////////////////////////{
////////////////////////////	struct ListNode* newnode = (struct ListNode*)malloc(sizeof(struct ListNode));
////////////////////////////	if (newnode == NULL)
////////////////////////////	{
////////////////////////////		printf("����ڵ�ʧ��\n");
////////////////////////////		exit(-1);
////////////////////////////	}
////////////////////////////	newnode->val = x;
////////////////////////////	newnode->next = NULL;
////////////////////////////	return newnode;
////////////////////////////}
////////////////////////////
////////////////////////////void SListPushBack(struct ListNode** phead, int x)//β������
////////////////////////////{
////////////////////////////	struct ListNode* newnode = BuySListNode(x);
////////////////////////////	struct ListNode* tail = *phead;
////////////////////////////	if (tail == NULL)
////////////////////////////	{
////////////////////////////		*phead = newnode;
////////////////////////////	}
////////////////////////////	else
////////////////////////////	{
////////////////////////////		while (tail->next != NULL)
////////////////////////////		{
////////////////////////////			tail = tail->next;
////////////////////////////		}
////////////////////////////		tail->next = newnode;
////////////////////////////	}
////////////////////////////}
////////////////////////////
////////////////////////////void SListPrint(struct ListNode** phead)//���
////////////////////////////{
////////////////////////////	struct ListNode* cur = *phead;
////////////////////////////	while (cur != NULL)
////////////////////////////	{
////////////////////////////		printf("%d->", cur->val);
////////////////////////////		cur = cur->next;
////////////////////////////	}
////////////////////////////	printf("NULL\n");
////////////////////////////}
////////////////////////////
////////////////////////////struct ListNode* reverseList(struct ListNode* head)
////////////////////////////{
////////////////////////////	if (head == NULL)
////////////////////////////	{
////////////////////////////		return head;
////////////////////////////	}
////////////////////////////	else
////////////////////////////	{
////////////////////////////		struct ListNode* tail = head->next;
////////////////////////////		head->next = NULL;
////////////////////////////		while (tail != NULL)
////////////////////////////		{
////////////////////////////			struct ListNode* newnode = (struct ListNode*)malloc(sizeof(struct ListNode));
////////////////////////////			newnode->val = tail->val;
////////////////////////////			newnode->next = head;
////////////////////////////			head = newnode;
////////////////////////////			tail = tail->next;
////////////////////////////		}
////////////////////////////	}
////////////////////////////	return head;
////////////////////////////}
////////////////////////////
////////////////////////////int main()
////////////////////////////{
////////////////////////////	struct ListNode* head = NULL;
////////////////////////////	SListPushBack(&head, 1);
////////////////////////////	SListPushBack(&head, 2);
////////////////////////////	SListPushBack(&head, 3);
////////////////////////////	SListPushBack(&head, 4);
////////////////////////////	SListPushBack(&head, 5);
////////////////////////////
////////////////////////////	head = reverseList(head);
////////////////////////////
////////////////////////////	SListPrint(&head);
////////////////////////////	return 0;
////////////////////////////}
//////////////////////////
//////////////////////////
////////////////////////////#include<stdio.h>
////////////////////////////#include<stdlib.h>
////////////////////////////
////////////////////////////struct ListNode
////////////////////////////{
////////////////////////////	int val;
////////////////////////////	struct ListNode* next;
////////////////////////////};
////////////////////////////
////////////////////////////struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2)
////////////////////////////{
////////////////////////////    struct ListNode* list1next;
////////////////////////////    struct ListNode* list2next;
////////////////////////////    struct ListNode* newlist = NULL;
////////////////////////////    struct ListNode* tail = NULL;
////////////////////////////    if (list1 == NULL && list2 == NULL)
////////////////////////////    {
////////////////////////////        return NULL;
////////////////////////////    }
////////////////////////////    if (list1 == NULL)
////////////////////////////    {
////////////////////////////        return list2;
////////////////////////////    }
////////////////////////////    if (list2 == NULL)
////////////////////////////    {
////////////////////////////        return list1;
////////////////////////////    }
////////////////////////////    while (list1 != NULL && list2 != NULL)
////////////////////////////    {
////////////////////////////        if ((list1->val) <= (list2->val))
////////////////////////////        {
////////////////////////////            if (newlist == NULL)
////////////////////////////            {
////////////////////////////                list1next = list1->next;
////////////////////////////                list1->next = newlist;
////////////////////////////                newlist = list1;
////////////////////////////                list1 = list1next;
////////////////////////////                tail = newlist;
////////////////////////////                list1 = list2next;
////////////////////////////            }
////////////////////////////            else
////////////////////////////            {
////////////////////////////                list1next = list1->next;
////////////////////////////                list1->next = tail->next;
////////////////////////////                tail->next = list1;
////////////////////////////                tail = tail->next;
////////////////////////////                list1 = list1next;
////////////////////////////            }
////////////////////////////        }
////////////////////////////        else
////////////////////////////        {
////////////////////////////            if (newlist == NULL)
////////////////////////////            {
////////////////////////////                list2next = list2->next;
////////////////////////////                list2->next = newlist;
////////////////////////////                newlist = list2;
////////////////////////////                list2 = list2next;
////////////////////////////                tail = newlist;
////////////////////////////                list2 = list2next;
////////////////////////////            }
////////////////////////////            else
////////////////////////////            {
////////////////////////////                list2next = list2->next;
////////////////////////////                list2->next = tail->next;
////////////////////////////                tail->next = list2;
////////////////////////////                tail = tail->next;
////////////////////////////            }
////////////////////////////        }
////////////////////////////    }
////////////////////////////    if (list1 == NULL)
////////////////////////////    {
////////////////////////////        tail->next = list2;
////////////////////////////    }
////////////////////////////    else
////////////////////////////    {
////////////////////////////        tail->next = list1;
////////////////////////////    }
////////////////////////////    return newlist;
////////////////////////////}
////////////////////////////
////////////////////////////int main()
////////////////////////////{
////////////////////////////	struct ListNode* A = (struct ListNode*)malloc(sizeof(struct ListNode));
////////////////////////////	A->val = 1;
////////////////////////////	struct ListNode* B = (struct ListNode*)malloc(sizeof(struct ListNode));
////////////////////////////	B->val = 2;
////////////////////////////	struct ListNode* C = (struct ListNode*)malloc(sizeof(struct ListNode));
////////////////////////////	C->val = 4;
////////////////////////////
////////////////////////////	A->next = B;
////////////////////////////	B->next = C;
////////////////////////////	C->next = NULL;
////////////////////////////	
////////////////////////////	struct ListNode* E = (struct ListNode*)malloc(sizeof(struct ListNode));
////////////////////////////	E->val = 1;
////////////////////////////	struct ListNode* F = (struct ListNode*)malloc(sizeof(struct ListNode));
////////////////////////////	F->val = 3;
////////////////////////////	struct ListNode* G = (struct ListNode*)malloc(sizeof(struct ListNode));
////////////////////////////	G->val = 4;
////////////////////////////
////////////////////////////	E->next = F;
////////////////////////////	F->next = G;
////////////////////////////	G->next = NULL;
////////////////////////////
////////////////////////////    mergeTwoLists(A, E);
////////////////////////////	return 0;
////////////////////////////}
//////////////////////////
//////////////////////////
////////////////////////////#include<stdio.h>
////////////////////////////#include<stdlib.h>
////////////////////////////
////////////////////////////typedef struct ListNode
////////////////////////////{
////////////////////////////	int val;
////////////////////////////	struct ListNode* next;
////////////////////////////}ListNode;
////////////////////////////
////////////////////////////ListNode* partition(ListNode* pHead, int x)
////////////////////////////{
////////////////////////////    int i = 0;
////////////////////////////    struct ListNode* first = (struct ListNode*)malloc(sizeof(struct ListNode));
////////////////////////////    first->next = pHead;
////////////////////////////    pHead = first;
////////////////////////////    struct ListNode* FirstPushBack = first;
////////////////////////////    struct ListNode* tail = pHead;
////////////////////////////    struct ListNode* move = pHead->next;
////////////////////////////    struct ListNode* movenext;
////////////////////////////    while (tail->next != NULL)
////////////////////////////    {
////////////////////////////        tail = tail->next;
////////////////////////////    }
////////////////////////////    while (move != FirstPushBack && move != NULL)
////////////////////////////    {
////////////////////////////        if (move->val >= x)
////////////////////////////        {
////////////////////////////            i++;
////////////////////////////            if (i == 1)
////////////////////////////            {
////////////////////////////                FirstPushBack = move;
////////////////////////////            }
////////////////////////////            movenext = move->next;
////////////////////////////            move->next = tail->next;
////////////////////////////            tail->next = move;
////////////////////////////            tail = tail->next;
////////////////////////////            first->next = movenext;
////////////////////////////            move = movenext;
////////////////////////////        }
////////////////////////////        else
////////////////////////////        {
////////////////////////////            first = first->next;
////////////////////////////            move = move->next;
////////////////////////////        }
////////////////////////////    }
////////////////////////////    return first->next;
////////////////////////////}
////////////////////////////
////////////////////////////ListNode* partition2(ListNode* pHead, int x)
////////////////////////////{
////////////////////////////    ListNode* smalllist = (ListNode*)malloc(sizeof(ListNode));
////////////////////////////    ListNode* biglist = (ListNode*)malloc(sizeof(ListNode));
////////////////////////////    ListNode* smalltail = smalllist;
////////////////////////////    ListNode* bigtail = biglist;
////////////////////////////    smalllist->next = NULL;
////////////////////////////    biglist->next = NULL;
////////////////////////////    ListNode* pHeadnext;
////////////////////////////    while (pHead != NULL)
////////////////////////////    {
////////////////////////////        if (pHead->val < x)
////////////////////////////        {
////////////////////////////            pHeadnext = pHead->next;
////////////////////////////            pHead->next = smalltail->next;
////////////////////////////            smalltail->next = pHead;
////////////////////////////            smalltail = smalltail->next;
////////////////////////////            pHead = pHeadnext;
////////////////////////////        }
////////////////////////////        else
////////////////////////////        {
////////////////////////////            pHeadnext = pHead->next;
////////////////////////////            pHead->next = bigtail->next;
////////////////////////////            bigtail->next = pHead;
////////////////////////////            bigtail = bigtail->next;
////////////////////////////            pHead = pHeadnext;
////////////////////////////        }
////////////////////////////    }
////////////////////////////    smalltail->next = biglist->next;
////////////////////////////    return smalltail;
////////////////////////////}
////////////////////////////
////////////////////////////int main()
////////////////////////////{
////////////////////////////	struct ListNode* a = (struct ListNode*)malloc(sizeof(struct ListNode));
////////////////////////////	a->val = 3;
////////////////////////////
////////////////////////////	struct ListNode* b = (struct ListNode*)malloc(sizeof(struct ListNode));
////////////////////////////	b->val = 3;
////////////////////////////
////////////////////////////	struct ListNode* c = (struct ListNode*)malloc(sizeof(struct ListNode));
////////////////////////////	c->val = 3;
////////////////////////////
////////////////////////////	//struct ListNode* d = (struct ListNode*)malloc(sizeof(struct ListNode));
////////////////////////////	//d->val = 8;
////////////////////////////
////////////////////////////	//struct ListNode* e = (struct ListNode*)malloc(sizeof(struct ListNode));
////////////////////////////	//e->val = 100;
////////////////////////////
////////////////////////////	//struct ListNode* f = (struct ListNode*)malloc(sizeof(struct ListNode));
////////////////////////////	//f->val = 90;
////////////////////////////
////////////////////////////	//struct ListNode* g = (struct ListNode*)malloc(sizeof(struct ListNode));
////////////////////////////	//g->val = 1;
////////////////////////////
////////////////////////////
////////////////////////////	a->next = b;
////////////////////////////	b->next = c;
////////////////////////////	c->next = NULL;
////////////////////////////	//d->next = e;
////////////////////////////	//e->next = f;
////////////////////////////	//f->next = g;
//////////////////////////// //   g->next = NULL;
////////////////////////////
////////////////////////////    partition2(a,3);
////////////////////////////
////////////////////////////    return 0;
////////////////////////////}
//////////////////////////
//////////////////////////
////////////////////////////#include<stdio.h>
////////////////////////////#include<stdlib.h>
////////////////////////////#include<limits.h>
////////////////////////////#define INT_MAX
////////////////////////////
////////////////////////////struct ListNode
////////////////////////////{
////////////////////////////	int val;
////////////////////////////	struct ListNode* next;
////////////////////////////};
////////////////////////////
////////////////////////////struct ListNode* detectCycle(struct ListNode* head)
////////////////////////////{
////////////////////////////    struct ListNode* arr[10000];
////////////////////////////    int size = 0;
////////////////////////////    while (head != NULL)
////////////////////////////    {
////////////////////////////        int i = 0;
////////////////////////////        while (i < size)
////////////////////////////        {
////////////////////////////            if (arr[i] == &(*head))
////////////////////////////            {
////////////////////////////                return head;
////////////////////////////            }
////////////////////////////            else
////////////////////////////            {
////////////////////////////                i++;
////////////////////////////            }
////////////////////////////        }
////////////////////////////        arr[size] = &(*head);
////////////////////////////        size++;
////////////////////////////        head = head->next;
////////////////////////////    }
////////////////////////////    return NULL;
////////////////////////////}
////////////////////////////
////////////////////////////int main()
////////////////////////////{
////////////////////////////	struct ListNode* a = (struct ListNode*)malloc(sizeof(struct ListNode));
////////////////////////////	a->val = 1;
////////////////////////////
////////////////////////////	struct ListNode* b = (struct ListNode*)malloc(sizeof(struct ListNode));
////////////////////////////	b->val = 2;
////////////////////////////
////////////////////////////	a->next = b;
////////////////////////////	b->next = NULL;
////////////////////////////
////////////////////////////    struct ListNode* ret=detectCycle(a);
////////////////////////////
////////////////////////////	return 0;
////////////////////////////}
//////////////////////////
//////////////////////////
////////////////////////////#include<stdio.h>
////////////////////////////#include<limits.h>
////////////////////////////
////////////////////////////int main()
////////////////////////////{
////////////////////////////	printf("%u", UINT_MAX);
////////////////////////////	return 0;
////////////////////////////}
//////////////////////////
////////////////////////////#include<stdio.h>
////////////////////////////#include<stdlib.h>
////////////////////////////
////////////////////////////
////////////////////////////
////////////////////////////struct Node
////////////////////////////{
////////////////////////////	int val;
////////////////////////////	struct Node* next;
////////////////////////////	struct Node* random;
////////////////////////////};
////////////////////////////
////////////////////////////struct Node* copyRandomList(struct Node* head)
////////////////////////////{
////////////////////////////    struct Node* first = (struct Node*)malloc(sizeof(struct Node));
////////////////////////////    first->next = NULL;
////////////////////////////
////////////////////////////    struct Node* tailfirst = first;
////////////////////////////    struct Node* tailhead = head;
////////////////////////////    while (tailhead != NULL)
////////////////////////////    {
////////////////////////////        struct Node* newnode = (struct Node*)malloc(sizeof(struct Node));
////////////////////////////        newnode->val = tailhead->val;
////////////////////////////        newnode->next = NULL;
////////////////////////////        tailfirst->next = newnode;
////////////////////////////        tailfirst = tailfirst->next;
////////////////////////////        tailhead = tailhead->next;
////////////////////////////    }
////////////////////////////    tailhead = head;
////////////////////////////    tailfirst = first;
////////////////////////////    while (tailhead != NULL)
////////////////////////////    {
////////////////////////////        struct Node* randomposition = tailhead->random;
////////////////////////////        int size = 1;
////////////////////////////        struct Node* find = head;
////////////////////////////        while (find != randomposition)
////////////////////////////        {
////////////////////////////            find = find->next;
////////////////////////////            size++;
////////////////////////////        }
////////////////////////////        struct Node* findfirst = first;
////////////////////////////        while (size--)
////////////////////////////        {
////////////////////////////            findfirst = findfirst->next;
////////////////////////////        }
////////////////////////////        tailfirst->next->random = findfirst;
////////////////////////////        tailfirst = tailfirst->next;
////////////////////////////        tailhead = tailhead->next;
////////////////////////////    }
////////////////////////////    return first->next;
////////////////////////////}
//////////////////////////
////////////////////////////int main()
////////////////////////////{
////////////////////////////	struct Node* a = malloc(sizeof(struct Node));
////////////////////////////	a->val = 7;
////////////////////////////	struct Node* b = malloc(sizeof(struct Node));
////////////////////////////	b->val = 13;
////////////////////////////	struct Node* c = malloc(sizeof(struct Node));
////////////////////////////	c->val = 11;
////////////////////////////	struct Node* d = malloc(sizeof(struct Node));
////////////////////////////	d->val = 10;
////////////////////////////	struct Node* e = malloc(sizeof(struct Node));
////////////////////////////	e->val = 1;
////////////////////////////
////////////////////////////	a->next = b;
////////////////////////////	b->next = c;
////////////////////////////	c->next = d;
////////////////////////////	d->next = e;
////////////////////////////	e->next = NULL;
////////////////////////////
////////////////////////////	a->random = NULL;
////////////////////////////	b->random = a;
////////////////////////////	c->random = e;
////////////////////////////	d->random = c;
////////////////////////////	e->random = a;
////////////////////////////
////////////////////////////    struct Node* ret = copyRandomList(a);
////////////////////////////
////////////////////////////
////////////////////////////	return 0;
////////////////////////////}
//////////////////////////
////////////////////////////
////////////////////////////#include<stdio.h>
////////////////////////////#include<stdlib.h>	
////////////////////////////
////////////////////////////typedef struct ListNode
////////////////////////////{
////////////////////////////	int val;
////////////////////////////	struct ListNode* next;
////////////////////////////}Node;
////////////////////////////
////////////////////////////struct ListNode* deleteDuplicates(struct ListNode* head)
////////////////////////////{
////////////////////////////    if (head == NULL || head->next == NULL)
////////////////////////////    {
////////////////////////////        return head;
////////////////////////////    }
////////////////////////////    Node* prev;
////////////////////////////    Node* mid = head;
////////////////////////////    Node* tail = head->next;
////////////////////////////    while (tail != NULL)
////////////////////////////    {
////////////////////////////        if (mid->val != tail->val)
////////////////////////////        {
////////////////////////////            prev = mid;
////////////////////////////            mid = mid->next;
////////////////////////////            tail = tail->next;
//////////////////////////        
////////////////////////////        else
////////////////////////////        {
////////////////////////////            while ((tail != NULL) && (mid->val == tail->val))
////////////////////////////            {
////////////////////////////                tail = tail->next;
////////////////////////////            }
////////////////////////////            prev->next = tail;
////////////////////////////            mid = prev;
////////////////////////////        }
////////////////////////////    }
////////////////////////////    return head;
////////////////////////////}
////////////////////////////
////////////////////////////int main()
////////////////////////////{
////////////////////////////	Node* a = malloc(sizeof(Node));
////////////////////////////	a->val = 1;
////////////////////////////	Node* b = malloc(sizeof(Node));
////////////////////////////	b->val = 2;
////////////////////////////	Node* c = malloc(sizeof(Node));
////////////////////////////	c->val = 3;
////////////////////////////	Node* d = malloc(sizeof(Node));
////////////////////////////	d->val = 3;
////////////////////////////	Node* e = malloc(sizeof(Node));
////////////////////////////	e->val = 4;
////////////////////////////	Node* f = malloc(sizeof(Node));
////////////////////////////	f->val = 4;
////////////////////////////	Node* g = malloc(sizeof(Node));
////////////////////////////	g->val = 5;
////////////////////////////
////////////////////////////	a->next = b;
////////////////////////////	b->next = c;
////////////////////////////	c->next = d;
////////////////////////////	d->next = e;
////////////////////////////	e->next = f;
////////////////////////////	f->next = g;
////////////////////////////	g->next = NULL;
////////////////////////////
////////////////////////////    Node* ret=deleteDuplicates(a);
////////////////////////////
////////////////////////////	return 0;
////////////////////////////}
//////////////////////////
////////////////////////////#include<stdio.h>
////////////////////////////#include<stdbool.h>
////////////////////////////
////////////////////////////bool compare(char c1, char c2)
////////////////////////////{
////////////////////////////    if (c1 == '(' && c2 == ')')
////////////////////////////    {
////////////////////////////        return true;
////////////////////////////    }
////////////////////////////    if (c1 == '[' && c2 == ']')
////////////////////////////    {
////////////////////////////        return true;
////////////////////////////    }
////////////////////////////    if (c1 == '{' && c2 == '}')
////////////////////////////    {
////////////////////////////        return true;
////////////////////////////    }
////////////////////////////    return false;
////////////////////////////}
////////////////////////////
////////////////////////////bool isValid(char* s)
////////////////////////////{
////////////////////////////    char arr[10];
////////////////////////////    int i = 0;
////////////////////////////    int j = 1;
////////////////////////////    while (s[i] != '\0')
////////////////////////////    {
////////////////////////////        arr[j] = s[i];
////////////////////////////        i++;
////////////////////////////        j++;
////////////////////////////        if (compare(arr[j-2], arr[j-1]))
////////////////////////////        {
////////////////////////////            j -= 1;
////////////////////////////        }
////////////////////////////    }
////////////////////////////    if (j == 1)
////////////////////////////    {
////////////////////////////        return true;
////////////////////////////    }
////////////////////////////    else
////////////////////////////    {
////////////////////////////        return false;
////////////////////////////    }
////////////////////////////}
////////////////////////////
////////////////////////////int main()
////////////////////////////{
////////////////////////////	char s[] = "()";
////////////////////////////    isValid(s);
////////////////////////////	return 0;
////////////////////////////}
//////////////////////////
////////////////////////////#include<stdio.h>
////////////////////////////
////////////////////////////int main()
////////////////////////////{
////////////////////////////	char a = '0';
////////////////////////////	char b = '1';
////////////////////////////	printf("%d %d\n", a, b);
////////////////////////////
////////////////////////////	return 0;
////////////////////////////}
//////////////////////////
//////////////////////////#include<stdio.h>
//////////////////////////#include<stdlib.h>
//////////////////////////#include<assert.h>
//////////////////////////#include<stdbool.h>
//////////////////////////
//////////////////////////typedef int Data;
//////////////////////////typedef struct QueueListNode
//////////////////////////{
//////////////////////////    Data val;
//////////////////////////    struct QueueListNode* next;
//////////////////////////}QueueListNode;
//////////////////////////
//////////////////////////typedef struct Queue
//////////////////////////{
//////////////////////////    QueueListNode* head;
//////////////////////////    QueueListNode* tail;
//////////////////////////}Queue;
//////////////////////////
//////////////////////////void QueueInit(Queue* pq)
//////////////////////////{
//////////////////////////    assert(pq);
//////////////////////////    pq->head = NULL;
//////////////////////////    pq->tail = NULL;
//////////////////////////}
//////////////////////////
//////////////////////////void QueuePush(Queue* pq, Data x)
//////////////////////////{
//////////////////////////    assert(pq);
//////////////////////////    QueueListNode* newnode = (QueueListNode*)malloc(sizeof(QueueListNode));
//////////////////////////    if (newnode == NULL)
//////////////////////////    {
//////////////////////////        printf("����ʧ��\n");
//////////////////////////        exit(-1);
//////////////////////////    }
//////////////////////////    newnode->val = x;
//////////////////////////    newnode->next = NULL;
//////////////////////////
//////////////////////////    if (pq->head == NULL)
//////////////////////////    {
//////////////////////////        pq->head = pq->tail = newnode;
//////////////////////////    }
//////////////////////////    else
//////////////////////////    {
//////////////////////////        pq->tail->next = newnode;
//////////////////////////        pq->tail = newnode;
//////////////////////////    }
//////////////////////////}
//////////////////////////
//////////////////////////void QueuePop(Queue* pq)
//////////////////////////{
//////////////////////////    assert(pq);
//////////////////////////    assert(pq->head != NULL);
//////////////////////////    QueueListNode* headNext = pq->head->next;
//////////////////////////    free(pq->head);
//////////////////////////    pq->head = headNext;
//////////////////////////}
//////////////////////////
//////////////////////////Data QueuePeek(Queue* pq)
//////////////////////////{
//////////////////////////    assert(pq);
//////////////////////////    assert(pq->head != NULL);
//////////////////////////    return pq->head->val;
//////////////////////////}
//////////////////////////
//////////////////////////int QueueSize(Queue* pq)
//////////////////////////{
//////////////////////////    assert(pq);
//////////////////////////    QueueListNode* cur = pq->head;
//////////////////////////    int count = 0;
//////////////////////////    while (cur != NULL)
//////////////////////////    {
//////////////////////////        count++;
//////////////////////////        cur = cur->next;
//////////////////////////    }
//////////////////////////    return count;
//////////////////////////}
//////////////////////////
//////////////////////////bool QueueEmpty(Queue* pq)
//////////////////////////{
//////////////////////////    assert(pq);
//////////////////////////    if (pq->head == NULL)
//////////////////////////    {
//////////////////////////        return true;
//////////////////////////    }
//////////////////////////    else
//////////////////////////    {
//////////////////////////        return false;
//////////////////////////    }
//////////////////////////}
//////////////////////////
//////////////////////////typedef struct
//////////////////////////{
//////////////////////////    Queue* Q1;//Ĭ��Q1Ϊ�洢���ݵĶ���
//////////////////////////    Queue* Q2;//
//////////////////////////    int size;
//////////////////////////} MyStack;
//////////////////////////
//////////////////////////
//////////////////////////MyStack* myStackCreate()
//////////////////////////{
//////////////////////////    MyStack* newStack = (MyStack*)malloc(sizeof(MyStack));
//////////////////////////    if (newStack == NULL)
//////////////////////////    {
//////////////////////////        printf("����ʧ��\n");
//////////////////////////        exit(-1);
//////////////////////////    }
//////////////////////////    newStack->size = 0;
//////////////////////////
//////////////////////////    Queue* q1 = (Queue*)malloc(sizeof(Queue));
//////////////////////////    Queue* q2 = (Queue*)malloc(sizeof(Queue));
//////////////////////////
//////////////////////////    newStack->Q1 = q1;
//////////////////////////    newStack->Q2 = q2;
//////////////////////////
//////////////////////////    QueueInit(newStack->Q1);
//////////////////////////    QueueInit(newStack->Q2);
//////////////////////////
//////////////////////////    return newStack;
//////////////////////////}
//////////////////////////
//////////////////////////void myStackPush(MyStack* obj, int x)
//////////////////////////{
//////////////////////////    assert(obj);
//////////////////////////    QueuePush(obj->Q1, x);
//////////////////////////    obj->size++;
//////////////////////////}
//////////////////////////
//////////////////////////int myStackPop(MyStack* obj)
//////////////////////////{
//////////////////////////    assert(obj);
//////////////////////////    Queue* tmp = obj->Q1;
//////////////////////////    obj->Q1 = obj->Q2;
//////////////////////////    obj->Q2 = tmp;
//////////////////////////    QueueListNode* cur = obj->Q2->head;
//////////////////////////
//////////////////////////    if (cur == obj->Q2->tail)
//////////////////////////    {
//////////////////////////        int ret = cur->val;
//////////////////////////        obj->Q2->head = obj->Q2->tail = NULL;
//////////////////////////        free(cur);
//////////////////////////        obj->size--;
//////////////////////////        return ret;
//////////////////////////    }
//////////////////////////
//////////////////////////    while (cur != obj->Q2->tail)
//////////////////////////    {
//////////////////////////        QueueListNode* curNext = cur->next;
//////////////////////////        int x = cur->val;
//////////////////////////        myStackPush(obj, x);
//////////////////////////        obj->size--;
//////////////////////////        free(cur);
//////////////////////////        cur = curNext;
//////////////////////////    }
//////////////////////////    int ret = cur->val;
//////////////////////////
//////////////////////////    free(cur);
//////////////////////////    obj->size--;
//////////////////////////    return ret;
//////////////////////////}
//////////////////////////
//////////////////////////int myStackTop(MyStack* obj)
//////////////////////////{
//////////////////////////    assert(obj);
//////////////////////////    return obj->Q1->tail->val;
//////////////////////////}
//////////////////////////
//////////////////////////bool myStackEmpty(MyStack* obj)
//////////////////////////{
//////////////////////////    assert(obj);
//////////////////////////    if (obj->size == 0)
//////////////////////////    {
//////////////////////////        return true;
//////////////////////////    }
//////////////////////////    else
//////////////////////////    {
//////////////////////////        return false;
//////////////////////////    }
//////////////////////////}
//////////////////////////
//////////////////////////void myStackFree(MyStack* obj)
//////////////////////////{
//////////////////////////    assert(obj);
//////////////////////////    QueueListNode* cur = obj->Q1->head;
//////////////////////////    while (cur != NULL)
//////////////////////////    {
//////////////////////////        QueueListNode* curNext = cur->next;
//////////////////////////        free(cur);
//////////////////////////        cur = curNext;
//////////////////////////    }
//////////////////////////    obj->Q1->head = obj->Q2->tail = NULL;
//////////////////////////}
//////////////////////////
///////////////////////////**
////////////////////////// * Your MyStack struct will be instantiated and called as such:
////////////////////////// * MyStack* obj = myStackCreate();
////////////////////////// * myStackPush(obj, x);
//////////////////////////
////////////////////////// * int param_2 = myStackPop(obj);
//////////////////////////
////////////////////////// * int param_3 = myStackTop(obj);
//////////////////////////
////////////////////////// * bool param_4 = myStackEmpty(obj);
//////////////////////////
////////////////////////// * myStackFree(obj);
//////////////////////////*/
//////////////////////////
//////////////////////////int main()
//////////////////////////{
//////////////////////////    MyStack* s1 = myStackCreate();
//////////////////////////    myStackPush(s1, 1);
//////////////////////////    myStackPush(s1, 2);
//////////////////////////    int ret=myStackTop(s1);
//////////////////////////    printf("%d\n", ret);
//////////////////////////    ret = myStackPop(s1);
//////////////////////////    printf("%d\n", ret);
//////////////////////////    ret = myStackPop(s1);
//////////////////////////    printf("%d\n", ret);
//////////////////////////
//////////////////////////    bool a = myStackEmpty(s1);
//////////////////////////    if (a == true)
//////////////////////////    {
//////////////////////////        printf("kong\n");
//////////////////////////    }
//////////////////////////    return 0;
//////////////////////////}
////////////////////////
////////////////////////
//////////////////////////#include<stdio.h>
//////////////////////////#include<stdlib.h>
//////////////////////////#include<assert.h>
//////////////////////////#include<stdbool.h>
//////////////////////////
//////////////////////////typedef struct Stack
//////////////////////////{
//////////////////////////    int* arr;
//////////////////////////    int top;
//////////////////////////    int capacity;
//////////////////////////}Stack;
//////////////////////////
//////////////////////////void StackInit(Stack* S)
//////////////////////////{
//////////////////////////    assert(S);
//////////////////////////    S->top = 0;
//////////////////////////    S->capacity = 4;
//////////////////////////    int* tmp = (int*)malloc(sizeof(int) * S->capacity);
//////////////////////////    if (tmp == NULL)
//////////////////////////    {
//////////////////////////        printf("����ʧ��\n");
//////////////////////////        exit(-1);
//////////////////////////    }
//////////////////////////    S->arr = tmp;
//////////////////////////}
//////////////////////////
//////////////////////////void StackPush(Stack* S, int x)
//////////////////////////{
//////////////////////////    assert(S);
//////////////////////////    if (S->top == S->capacity)
//////////////////////////    {
//////////////////////////        S->capacity = S->capacity * 2;
//////////////////////////        int* tmp = (int*)realloc(S->arr, sizeof(S->capacity));
//////////////////////////        if (tmp == NULL)
//////////////////////////        {
//////////////////////////            printf("����ʧ��\n");
//////////////////////////            exit(-1);
//////////////////////////        }
//////////////////////////        S->arr = tmp;
//////////////////////////    }
//////////////////////////    S->arr[S->top] = x;
//////////////////////////    S->top++;
//////////////////////////}
//////////////////////////
//////////////////////////void StackPop(Stack* S)
//////////////////////////{
//////////////////////////    assert(S);
//////////////////////////    S->top--;
//////////////////////////}
//////////////////////////
//////////////////////////int StackPeek(Stack* S)
//////////////////////////{
//////////////////////////    assert(S);
//////////////////////////    return S->arr[S->top - 1];
//////////////////////////}
//////////////////////////
//////////////////////////bool StackEmpty(Stack* S)
//////////////////////////{
//////////////////////////    if (S->top == 0)
//////////////////////////    {
//////////////////////////        return true;
//////////////////////////    }
//////////////////////////    else
//////////////////////////    {
//////////////////////////        return false;
//////////////////////////    }
//////////////////////////}
//////////////////////////
//////////////////////////typedef struct
//////////////////////////{
//////////////////////////    Stack PushST;
//////////////////////////    Stack PopST;
//////////////////////////} MyQueue;
//////////////////////////
//////////////////////////
//////////////////////////MyQueue* myQueueCreate()
//////////////////////////{
//////////////////////////    MyQueue* newQueue = (MyQueue*)malloc(sizeof(MyQueue));
//////////////////////////    if (newQueue == NULL)
//////////////////////////    {
//////////////////////////        printf("����ʧ��\n");
//////////////////////////        exit(-1);
//////////////////////////    }
//////////////////////////    StackInit(&(newQueue->PushST));
//////////////////////////    StackInit(&(newQueue->PopST));
//////////////////////////    return newQueue;
//////////////////////////}
//////////////////////////
//////////////////////////void myQueuePush(MyQueue* obj, int x)
//////////////////////////{
//////////////////////////    assert(obj);
//////////////////////////    StackPush(&(obj->PushST), x);
//////////////////////////}
//////////////////////////
//////////////////////////int myQueuePop(MyQueue* obj)
//////////////////////////{
//////////////////////////    assert(obj);
//////////////////////////    if ((obj->PopST).top == 0)
//////////////////////////    {
//////////////////////////        while (!StackEmpty(&(obj->PushST)))
//////////////////////////        {
//////////////////////////            int top = StackPeek(&(obj->PushST));
//////////////////////////            StackPop(&(obj->PushST));
//////////////////////////            StackPush(&(obj->PopST), top);
//////////////////////////        }
//////////////////////////    }
//////////////////////////    int pop = StackPeek(&(obj->PopST));
//////////////////////////    StackPop(&(obj->PopST));
//////////////////////////    return pop;
//////////////////////////}
//////////////////////////
//////////////////////////int myQueuePeek(MyQueue* obj)
//////////////////////////{
//////////////////////////    assert(obj);
//////////////////////////    if ((obj->PopST).top == 0)
//////////////////////////    {
//////////////////////////        while (!StackEmpty(&(obj->PushST)))
//////////////////////////        {
//////////////////////////            int top = StackPeek(&(obj->PushST));
//////////////////////////            StackPop(&(obj->PushST));
//////////////////////////            StackPush(&(obj->PopST), top);
//////////////////////////        }
//////////////////////////    }
//////////////////////////    return StackPeek(&(obj->PopST));
//////////////////////////}
//////////////////////////
//////////////////////////bool myQueueEmpty(MyQueue* obj)
//////////////////////////{
//////////////////////////    if (StackEmpty(&(obj->PushST)) && StackEmpty(&(obj->PopST)))
//////////////////////////    {
//////////////////////////        return true;
//////////////////////////    }
//////////////////////////    else
//////////////////////////    {
//////////////////////////        return false;
//////////////////////////    }
//////////////////////////}
//////////////////////////
//////////////////////////void myQueueFree(MyQueue* obj)
//////////////////////////{
//////////////////////////    assert(obj);
//////////////////////////    free((obj->PushST).arr);
//////////////////////////    free((obj->PopST).arr);
//////////////////////////}
//////////////////////////
///////////////////////////**
////////////////////////// * Your MyQueue struct will be instantiated and called as such:
////////////////////////// * MyQueue* obj = myQueueCreate();
////////////////////////// * myQueuePush(obj, x);
//////////////////////////
////////////////////////// * int param_2 = myQueuePop(obj);
//////////////////////////
////////////////////////// * int param_3 = myQueuePeek(obj);
//////////////////////////
////////////////////////// * bool param_4 = myQueueEmpty(obj);
//////////////////////////
////////////////////////// * myQueueFree(obj);
//////////////////////////*/
//////////////////////////
//////////////////////////int main()
//////////////////////////{
//////////////////////////    MyQueue* Q = myQueueCreate();
//////////////////////////    myQueuePush(Q, 1);
//////////////////////////    //int ret = myQueuePeek(Q);
//////////////////////////    //printf("%d\n", ret);
//////////////////////////    myQueuePop(Q);
//////////////////////////    //myQueuePop(Q);
//////////////////////////    return 0;
//////////////////////////}
////////////////////////
////////////////////////
//////////////////////////#include<stdio.h>
//////////////////////////#include<stdlib.h>
//////////////////////////
//////////////////////////void my_memset(void* dest,void val,)
//////////////////////////
//////////////////////////int main()
//////////////////////////{
//////////////////////////	char arr[10] = { 0 };
//////////////////////////	memset(arr, 'a', (sizeof(arr) / sizeof(char)) - 1);
//////////////////////////	printf(arr);
//////////////////////////}
////////////////////////
//////////////////////////#include<stdio.h>
//////////////////////////#include<stdlib.h>
//////////////////////////#include<string.h>
//////////////////////////
//////////////////////////
//////////////////////////void swap(int* sum1, int* sum2)//�������е�������
//////////////////////////{
//////////////////////////    int tmp = *sum1;
//////////////////////////    *sum1 = *sum2;
//////////////////////////    *sum2 = tmp;
//////////////////////////}
//////////////////////////
//////////////////////////void AdjustDown(int* arr, int k, int root)//���µ����㷨  kΪ�ѵ�Ԫ�ظ���  rootΪ���Ǹ�����㿪ʼ��
//////////////////////////{
//////////////////////////    int parent = root;
//////////////////////////    int child = parent * 2 + 1;
//////////////////////////
//////////////////////////    while (child < k)
//////////////////////////    {
//////////////////////////        if ((child + 1) < k && arr[child + 1] > arr[child] )
//////////////////////////        {
//////////////////////////            child++;
//////////////////////////        }
//////////////////////////        if (arr[child] > arr[parent])
//////////////////////////        {
//////////////////////////            swap(&(arr[child]), &(arr[parent]));
//////////////////////////            parent = child;
//////////////////////////            child = parent * 2 + 1;
//////////////////////////        }
//////////////////////////        else
//////////////////////////        {
//////////////////////////            break;
//////////////////////////        }
//////////////////////////    }
//////////////////////////
//////////////////////////}
//////////////////////////
///////////////////////////**
////////////////////////// * Note: The returned array must be malloced, assume caller calls free().
////////////////////////// */
//////////////////////////int* smallestK(int* arr, int arrSize, int k, int* returnSize)//�����
//////////////////////////{
//////////////////////////    if (k == 0)
//////////////////////////    {
//////////////////////////        *returnSize = 0;
//////////////////////////        return NULL;
//////////////////////////    }
//////////////////////////    int* tmp = (int*)malloc(sizeof(int) * k);//����k���ռ������     tmpΪ���
//////////////////////////    if (tmp == NULL)
//////////////////////////    {
//////////////////////////        printf("����ʧ��\n");
//////////////////////////        exit(-1);
//////////////////////////    }
//////////////////////////
//////////////////////////    memcpy(tmp, arr, sizeof(int) * k);
//////////////////////////
//////////////////////////    for (int i = (k - 1 - 1) / 2; i >= 0; i--)
//////////////////////////    {
//////////////////////////        AdjustDown(tmp, k, i);//���µ�����
//////////////////////////    }
//////////////////////////
//////////////////////////    for (int i = k; i < arrSize; i++)
//////////////////////////    {
//////////////////////////        if (arr[i] < tmp[0])
//////////////////////////        {
//////////////////////////            tmp[0] = arr[i];
//////////////////////////            AdjustDown(tmp, k, 0);
//////////////////////////        }
//////////////////////////    }
//////////////////////////    *returnSize = k;
//////////////////////////    return tmp;
//////////////////////////}
//////////////////////////
//////////////////////////
//////////////////////////int main()
//////////////////////////{
//////////////////////////	int arr[] = { 1,3,5,7,2,4,6,8 };
//////////////////////////    int ret;
//////////////////////////    int* retarr=smallestK(arr, sizeof(arr) / sizeof(int), 4, &ret);
//////////////////////////
//////////////////////////
//////////////////////////	return 0;
//////////////////////////}
////////////////////////
////////////////////////
////////////////////////#include<stdio.h>
////////////////////////
////////////////////////int BinarySearch(int* arr, int sz, int x)
////////////////////////{
////////////////////////	int head = 0;
////////////////////////	int tail = sz - 1;
////////////////////////	while (head <= tail)
////////////////////////	{
////////////////////////		int mid = (head + tail) / 2;
////////////////////////		if (arr[mid] > x)
////////////////////////		{
////////////////////////			tail = mid - 1;
////////////////////////		}
////////////////////////		else if (arr[mid] < x)
////////////////////////		{
////////////////////////			head = mid + 1;
////////////////////////		}
////////////////////////		else
////////////////////////		{
////////////////////////			return mid;
////////////////////////		}
////////////////////////	}
////////////////////////}
////////////////////////
////////////////////////int main()
////////////////////////{
////////////////////////	int arr[] = { 1,3,5,6 };
////////////////////////	int ret = BinarySearch(arr, sizeof(arr) / sizeof(int), 6);
////////////////////////	printf("%d\n", ret);
////////////////////////
////////////////////////	return 0;
////////////////////////}
//////////////////////
//////////////////////#include<stdio.h>
//////////////////////#include<malloc.h>
//////////////////////int* plusOne(int* digits, int digitsSize, int* returnSize)
//////////////////////{
//////////////////////    for (int i = digitsSize - 1; i >= 0; i++)
//////////////////////    {
//////////////////////        if (i == 0 && digits[i] == 9)
//////////////////////        {
//////////////////////            int* tmp = (int*)malloc(sizeof(int) * (digitsSize + 1));
//////////////////////            if (tmp == NULL)
//////////////////////            {
//////////////////////                printf("malloc false\n");
//////////////////////                exit(-1);
//////////////////////            }
//////////////////////            tmp[0] = 1;
//////////////////////            for (int j = 1; j <= digitsSize; j++)
//////////////////////            {
//////////////////////                tmp[j] = 0;
//////////////////////            }
//////////////////////            *returnSize = digitsSize + 1;
//////////////////////            return tmp;
//////////////////////        }
//////////////////////        if (digits[i] == 9)
//////////////////////        {
//////////////////////            digits[i] = 0;
//////////////////////        }
//////////////////////        else
//////////////////////        {
//////////////////////            digits[i] += 1;
//////////////////////            break;
//////////////////////        }
//////////////////////    }
//////////////////////    *returnSize = digitsSize;
//////////////////////    return digits;
//////////////////////}
//////////////////////
//////////////////////int main()
//////////////////////{
//////////////////////    int arr[] = { 9,9 };
//////////////////////    int a = 0;
//////////////////////    int* ret=plusOne(arr, sizeof(arr) / sizeof(int), &a);
//////////////////////    for (int i = 0; i < a; i++)
//////////////////////    {
//////////////////////        printf("%d ", ret[i]);
//////////////////////    }
//////////////////////	return 0;
//////////////////////}
////////////////////
////////////////////#include<stdio.h>
////////////////////
//////////////////////int main()
//////////////////////{
//////////////////////	char s1[10];
//////////////////////	scanf("%9s", s1);
//////////////////////	printf(s1);
//////////////////////	printf("\n");
//////////////////////
//////////////////////	while (getchar() != '\n')
//////////////////////	{
//////////////////////		;
//////////////////////	}
//////////////////////
//////////////////////	char s2[101];
//////////////////////	scanf("%100s", s2);
//////////////////////	printf(s2);
//////////////////////	return 0;
//////////////////////}
//////////////////////#include <stdio.h>
//////////////////////int main()
//////////////////////{
//////////////////////	int i = 0, a = 0, b = 2, c = 3, d = 4;
//////////////////////	//i = a++ && ++b && d++;
//////////////////////	i = a++||++b||d++;
//////////////////////	printf("a = %d\n b = %d\n c = %d\nd = %d\n", a, b, c, d);
//////////////////////	return 0;
//////////////////////}
////////////////////
////////////////////
////////////////////#include<stdio.h>
////////////////////#include<stdlib.h>
////////////////////
////////////////////typedef int BTData;
////////////////////
////////////////////typedef struct TreeNode
////////////////////{
////////////////////    BTData val;
////////////////////    struct TreeNode* left;
////////////////////    struct TreeNode* right;
////////////////////}TreeNode;
////////////////////
////////////////////int TreeSize(struct TreeNode* root)
////////////////////{
////////////////////    if (root == NULL)
////////////////////    {
////////////////////        return 0;
////////////////////    }
////////////////////    else
////////////////////    {
////////////////////        return 1 + TreeSize(root->left) + TreeSize(root->right);
////////////////////    }
////////////////////}
////////////////////
////////////////////void prevOrder(struct TreeNode* root, int* ret, int* count)
////////////////////{
////////////////////    if (root == NULL)
////////////////////    {
////////////////////        return;
////////////////////    }
////////////////////    ret[*count] = root->val;
////////////////////    *count
////////////////////    prevOrder(root->left, ret, count);
////////////////////    prevOrder(root->right, ret, count);
////////////////////}
////////////////////
////////////////////int* preorderTraversal(struct TreeNode* root, int* returnSize)
////////////////////{
////////////////////    int size = TreeSize(root);
////////////////////    int* ret = (int*)malloc(sizeof(int) * size);
////////////////////    if (ret == NULL)
////////////////////    {
////////////////////        printf("malloc false\n");
////////////////////        exit(-1);
////////////////////    }
////////////////////    int count = 0;
////////////////////    prevOrder(root, ret, &count);
////////////////////    *returnSize = count;
////////////////////    return ret;
////////////////////}
////////////////////
////////////////////TreeNode* BuyNode(BTData x)
////////////////////{
////////////////////    TreeNode* newnode = (TreeNode*)malloc(sizeof(TreeNode));
////////////////////    if (newnode == NULL)
////////////////////    {
////////////////////        printf("����ʧ��\n");
////////////////////        exit(-1);
////////////////////    }
////////////////////    newnode->val = x;
////////////////////    newnode->right = NULL;
////////////////////    newnode->left = NULL;
////////////////////    return newnode;
////////////////////}
////////////////////
////////////////////int main()
////////////////////{
////////////////////    TreeNode* A = BuyNode(1);
////////////////////    TreeNode* B = BuyNode(2);
////////////////////    TreeNode* C = BuyNode(3);
////////////////////
////////////////////    A->right = B;
////////////////////    B->left = C;
////////////////////    
////////////////////    int size = 0;
////////////////////    preorderTraversal(A, &size);
////////////////////
////////////////////	return 0;
////////////////////}
//////////////////
//////////////////#include<stdio.h>
//////////////////#include<stdlib.h>
//////////////////#include<stdbool.h>
//////////////////
//////////////////typedef int BTData;
//////////////////
//////////////////typedef struct TreeNode
//////////////////{
//////////////////    BTData val;
//////////////////    struct TreeNode* left;
//////////////////    struct TreeNode* right;
//////////////////}TreeNode;
//////////////////
//////////////////bool isUnivalTree(struct TreeNode* root)
//////////////////{
//////////////////    bool ret1 = true;
//////////////////    bool ret2 = true;
//////////////////    if (root->left != NULL && root->val == root->left->val)
//////////////////    {
//////////////////        ret1 = isUnivalTree(root->left);
//////////////////    }
//////////////////    else if (root->left != NULL && root->val != root->left->val)
//////////////////    {
//////////////////        ret1 = false;
//////////////////    }
//////////////////
//////////////////    if (root->right != NULL && root->val == root->right->val)
//////////////////    {
//////////////////        ret2 = isUnivalTree(root->right);
//////////////////    }
//////////////////    else if (root->right != NULL && root->val != root->right->val)
//////////////////    {
//////////////////        ret2 = false;
//////////////////    }
//////////////////
//////////////////    if (ret1 == true && ret2 == true)
//////////////////    {
//////////////////        return true;
//////////////////    }
//////////////////    else
//////////////////    {
//////////////////        return false;
//////////////////    }
//////////////////}
//////////////////
//////////////////TreeNode* BuyNode(BTData x)
//////////////////{
//////////////////    TreeNode* newnode = (TreeNode*)malloc(sizeof(TreeNode));
//////////////////    if (newnode == NULL)
//////////////////    {
//////////////////        printf("����ʧ��\n");
//////////////////        exit(-1);
//////////////////    }
//////////////////    newnode->val = x;
//////////////////    newnode->right = NULL;
//////////////////    newnode->left = NULL;
//////////////////    return newnode;
//////////////////}
//////////////////
//////////////////int main()
//////////////////{
//////////////////    TreeNode* A = BuyNode(1);
//////////////////    TreeNode* B = BuyNode(1);
//////////////////    TreeNode* C = BuyNode(1);
//////////////////    TreeNode* D = BuyNode(1);
//////////////////
//////////////////    A->left = B;
//////////////////    A->right = C;
//////////////////    B->left = D;
//////////////////
//////////////////    bool ret = isUnivalTree(A);
//////////////////    if (ret == true)
//////////////////    {
//////////////////        printf("1");
//////////////////    }
//////////////////
//////////////////    return 0;
//////////////////}
////////////////
//////////////////
//////////////////#include<stdio.h>
//////////////////
//////////////////void aaa(int* arr)
//////////////////{
//////////////////	int a = sizeof(arr) / sizeof(int);
//////////////////
//////////////////	printf("%d\n", a);
//////////////////}
//////////////////
//////////////////int main()
//////////////////{
//////////////////	int arr[] = { 1,2,3,4,5,6,7,8,9};
//////////////////	aaa(arr);
//////////////////	return 0;
//////////////////}
////////////////
////////////////#include<stdio.h>
////////////////#include<assert.h>
////////////////
////////////////int GetMidIndex(int* arr, int begin, int end)
////////////////{
////////////////	assert(arr);
////////////////
////////////////	int mid = (begin + end) / 2;
////////////////	if (arr[begin] > arr[mid])
////////////////	{
////////////////		if (arr[begin] > arr[end])
////////////////		{
////////////////			return arr[mid] > arr[end] ? mid : end;
////////////////		}
////////////////	}
////////////////	else if (arr[mid] > arr[end])
////////////////	{
////////////////		if (arr[mid] > arr[begin])
////////////////		{
////////////////			return arr[end] > arr[begin] ? end : begin;
////////////////		}
////////////////	}
////////////////	else
////////////////	{
////////////////		return arr[begin] > arr[mid] ? begin : mid;
////////////////	}
////////////////}
////////////////
////////////////int main()
////////////////{
////////////////	int arr1[] = { 1,2,3 };
////////////////	int arr2[] = { 1,3,2 };
////////////////	int arr3[] = { 2,1,3 };
////////////////	int arr4[] = { 2,3,1 };
////////////////	int arr5[] = { 3,1,2 };
////////////////	int arr6[] = { 3,2,1 };
////////////////
////////////////	int arr7[] = { 2,2,2 };
////////////////
////////////////	int arr8[] = { 2,2,3 };
////////////////	int arr9[] = { 3,2,2 };
////////////////	int arr10[] = { 2,3,2 };
////////////////
////////////////	int arr11[] = { 3,3,2 };
////////////////	int arr12[] = { 3,2,3 };
////////////////	int arr13[] = { 2,3,3 };
////////////////
////////////////
////////////////	printf("%d\n", GetMidIndex(arr1, 0, 2));
////////////////	printf("%d\n", GetMidIndex(arr2, 0, 2));
////////////////	printf("%d\n", GetMidIndex(arr3, 0, 2));
////////////////	printf("%d\n", GetMidIndex(arr4, 0, 2));
////////////////	printf("%d\n", GetMidIndex(arr5, 0, 2));
////////////////	printf("%d\n", GetMidIndex(arr6, 0, 2));
////////////////	printf("\n");
////////////////	printf("%d\n", GetMidIndex(arr7, 0, 2));
////////////////	printf("%d\n", GetMidIndex(arr8, 0, 2));
////////////////	printf("%d\n", GetMidIndex(arr9, 0, 2));
////////////////	printf("%d\n", GetMidIndex(arr10, 0, 2));
////////////////	printf("\n");
////////////////	printf("%d\n", GetMidIndex(arr11, 0, 2));
////////////////	printf("%d\n", GetMidIndex(arr12, 0, 2));
////////////////	printf("%d\n", GetMidIndex(arr13, 0, 2));
////////////////
////////////////
////////////////	return 0;
////////////////}
//////////////
//////////////
//////////////#include<stdio.h>
//////////////#include<stdlib.h>
//////////////#include<time.h>
//////////////
//////////////int compare(const void* sum1, const void* sum2)
//////////////{
//////////////	return *(int*)sum1 - *(int*)sum2;
//////////////}
//////////////
//////////////int main()
//////////////{
//////////////	srand((int)time(NULL));
//////////////
//////////////	//int arr[] = { 45,48,65,12,4,6,9, };
//////////////
//////////////	//qsort(arr, sizeof(arr) / sizeof(int), sizeof(int), compare);
//////////////
//////////////	//for (int i = 0; i < sizeof(arr) / sizeof(int); i++)
//////////////	//{
//////////////	//	printf("%d ", arr[i]);
//////////////	//}
//////////////
//////////////	//printf("\n");
//////////////
//////////////	int N = 100000000;
//////////////	int* a = (int*)malloc(sizeof(int) * N);
//////////////
//////////////	for (int i= 0; i < N; i++)
//////////////	{
//////////////		a[i] = rand();
//////////////	}
//////////////
//////////////	int begin = clock();
//////////////	qsort(a, N, sizeof(int), compare);
//////////////	int end = clock();
//////////////
//////////////	//for (int i = 0; i < N; i++)
//////////////	//{
//////////////	//	printf("%d ", a[i]);
//////////////	//}
//////////////
//////////////	printf("time:%d\n", end - begin);
//////////////
//////////////	return 0;
//////////////}
////////////#include<stdio.h>
////////////
////////////int main()
////////////{
////////////	int a = 10;
////////////
////////////	int count = 0;
////////////	
////////////	//for (int i = 0; i < 32; i++)
////////////	//{
////////////	//	if ((a >> i) & 1)
////////////	//	{
////////////	//		count++;
////////////	//	}
////////////	//}
////////////	//printf("%d\n", count);
////////////
////////////	while (a)
////////////	{
////////////		a = a & (a - 1);
////////////		count++;
////////////	}
////////////	/printf("%d\n", count);
////////////
////////////
////////////	return 0;
////////////}
//////////
////////////#include<stdio.h>
////////////
////////////int main()
////////////{
////////////	int a = 10;
////////////	const int* pa = &a;
////////////
////////////	a = 20;
////////////
////////////	return 0;
////////////}
//////////
////////////void Swap(int* num1, int* num2)
////////////{
////////////	int tmp = *num1;
////////////	*num1 = *num2;
////////////	*num2 = tmp;
////////////}
////////////
////////////#include<stdio.h>
////////////
////////////void Print(int* arr, int sz)
////////////{
////////////	for (int i = 0; i < sz; i++)
////////////	{
////////////		printf("%d ", arr[i]);
////////////	}
////////////	printf("\n");
////////////}
////////////
////////////void InserSort(int* arr, int sz)
////////////{
////////////
////////////	for (int i = 0; i < sz -1 ; i++)
////////////	{
////////////		int end = i;//已经有序序列中的最后一个元素
////////////		int tmp = arr[end + 1];//待排数据
////////////
////////////		while (end != -1)
////////////		{
////////////			if (tmp < arr[end])
////////////			{
////////////				arr[end + 1] = arr[end];
////////////				end--;
////////////			}
////////////			else
////////////			{
////////////				break;
////////////			}
////////////		}
////////////
////////////		arr[end + 1] = tmp;
////////////	}
////////////}
////////////
////////////void ShellSort(int* arr, int sz)
////////////{
////////////
////////////	int gap = sz;//gap取一个值
////////////
////////////	while (gap > 1)
////////////	{
////////////		gap = gap / 3 + 1;
////////////
////////////		for (int i = 0; i < sz - gap; i++)
////////////		{
////////////			int end = i;//表示有序数组中最后一个元素
////////////			int tmp = arr[end + gap];//待排的数据
////////////
////////////			while (end >= 0)
////////////			{
////////////				if (tmp < arr[end])
////////////				{
////////////					arr[end + gap] = arr[end];//则将end位置的移动到end+gap
////////////					end = end - gap;
////////////				}
////////////				else
////////////				{
////////////					break;
////////////				}
////////////			}
////////////
////////////			arr[end + gap] = tmp;//把待排的数放到对应的位置
////////////		}
////////////	}
////////////}
////////////
////////////int main()
////////////{
////////////	int arr1[] = { 100,5,48,65,43,2,5,9 };
////////////	int arr2[] = { 15, 20, 48, 6, 3, 1 ,4 ,2 };
////////////
////////////	InserSort(arr1, sizeof(arr1) / sizeof(int));
////////////	ShellSort(arr2, sizeof(arr2) / sizeof(int));
////////////
////////////	Print(arr1, sizeof(arr1) / sizeof(int));
////////////	Print(arr2, sizeof(arr2) / sizeof(int));
////////////
////////////	return 0;
////////////}
//////////
//////////#include<stdio.h>
//////////
//////////void Print(int* arr, int sz)//打印数组
//////////{
//////////	for (int i = 0; i < sz; i++)
//////////	{
//////////		printf("%d ", arr[i]);
//////////	}
//////////	printf("\n");
//////////}
//////////
//////////void Swap(int* num1, int* num2)//交换数组中的两个数
//////////{
//////////	int tmp = *num1;
//////////	*num1 = *num2;
//////////	*num2 = tmp;
//////////}
//////////
//////////void SelectSort(int* arr, int sz)//选择排序
//////////{
//////////	for (int i = sz - 1; i > 0; i--)
//////////	{
//////////		int max = 0;
//////////		int begin = 0;
//////////		int end = i;
//////////
//////////		for (int i = begin; i < end; i++)
//////////		{
//////////			if (arr[i] > arr[max])
//////////			{
//////////				max = i;
//////////			}
//////////		}
//////////
//////////		Swap(&arr[end], &arr[max]);
//////////	}
//////////}
//////////
//////////void AdjustDown(int* arr, int sz, int root)//向下调整算法，用于堆排序
//////////{
//////////	int parent = root;
//////////	int child = 2 * parent + 1;
//////////
//////////	while (child < sz)
//////////	{
//////////		if ((child + 1) < sz && arr[child + 1] > arr[child])
//////////		{
//////////			child++;
//////////		}
//////////
//////////		if (arr[child] > arr[parent])
//////////		{
//////////			Swap(&arr[child], &arr[parent]);
//////////			parent = child;
//////////			child = 2 * parent + 1;
//////////		}
//////////		else
//////////		{
//////////			break;
//////////		}
//////////	}
//////////}
//////////
//////////void HeapSort(int* arr, int sz)//堆排序
//////////{
//////////	for (int i = (sz - 1 - 1) / 2; i >= 0; i--)
//////////	{
//////////		AdjustDown(arr, sz, i);
//////////	}
//////////
//////////	for (int i = sz - 1; i > 0; i--)
//////////	{
//////////		Swap(&arr[0], &arr[i]);
//////////		AdjustDown(arr, i, 0);
//////////	}
//////////}
//////////
//////////int main()
//////////{
//////////	int arr1[] = { 15,48,96,20,13,5,74,18,2 };
//////////	int arr2[] = { 51,14,2,3,5,4,9,78 };
//////////
//////////	SelectSort(arr1, sizeof(arr1) / sizeof(int));
//////////	HeapSort(arr2, sizeof(arr2) / sizeof(int));
//////////
//////////	Print(arr1, sizeof(arr1) / sizeof(int));
//////////	Print(arr2, sizeof(arr2) / sizeof(int));
//////////
//////////	return 0;
//////////}
////////
////////#include<stdio.h>
////////#include<string.h>
////////
////////int main()
////////{
////////    char arr[1000];
////////    scanf("%s", &arr);
////////
////////    char input[1000];
////////    scanf("%s", &input);
////////
////////    int len1 = strlen(arr);
////////    int len2 = strlen(input);
////////
////////
////////    int count = 0;
////////
////////    for (int k = 0; k < len1; k++)
////////    {
////////        int begin = k;
////////        int j = 0;
////////
////////        for (int i = begin; i <= len1; i++)
////////        {
////////            if (i == len1)
////////            {
////////                i = 0;
////////            }
////////
////////            if (j == len2)
////////            {
////////                break;
////////            }
////////
////////            if (arr[i] == input[j])
////////            {
////////                j++;
////////            }
////////            else
////////            {
////////                break;
////////            }
////////        }
////////
////////        if (j == len2)
////////        {
////////            count++;
////////        }
////////    }
////////
////////    printf("%d\n", count);
////////
////////
////////    return 0;
////////}
//////
//////#include<stdio.h>
//////#include<stdlib.h>
//////
//////int count(int n)
//////{
//////    int a = 0;
//////    while (n)
//////    {
//////        n = n / 2;
//////        a++;
//////    }
//////    return a;
//////}
//////
//////int main()
//////{
//////    int group = 0;
//////
//////    int* arr = (int*)malloc(sizeof(int) * 200000);
//////    if (arr == NULL)
//////    {
//////        printf("malloc false\n");
//////        exit(-1);
//////    }
//////
//////    scanf("%d", &group);
//////    for (int i = 0; i < group; i++)
//////    {
//////        scanf("%d", arr[i]);
//////    }
//////
//////    for (int i = 0; i < group; i++)
//////    {
//////        int ret = count(arr[i]);
//////        printf("%d\n", ret);
//////    }
//////
//////    return 0;
//////}
////
//////#include<stdio.h>
//////int main()
//////{
//////	const char* pstr = "hello bit.";//这⾥是把⼀个字符串放到pstr指针变量⾥了吗？
//////	printf("%s\n", pstr);
//////	return 0;
//////}
////
//////#include<stdio.h>
//////#include<string.h>
//////int main()
//////{
//////    char arr[10] = { 0 };
//////    scanf("%s", &arr);
//////    char str[26] = { 0 };
//////    char ch = 'a';
//////    for (int i = 0; i < 26; i++)
//////    {
//////        str[i] = ch;
//////        ch++;
//////    }
//////
//////    int len = strlen(arr);
//////    for (int i = 0; i < len; i++)
//////    {
//////        int a = (int)(arr[i]);
//////        a = a - 97;
//////        str[a]++;
//////    }
//////    int max = 0;
//////    for (int i = 0; i < 26; i++)
//////    {
//////        if (arr[i] > arr[max])
//////        {
//////            max = i;
//////        }
//////    }
//////    printf("%c\n", max + 97);
//////    printf("%d\n", max);
//////    return 0;
//////}
//////
//////#include<stdio.h>
//////#include<string.h>
//////
//////int main()
//////{
//////    char input[10] = { 0 };
//////    scanf("%s", &input);//
//////
//////    int count[26] = { 0 };//
//////
//////    int len = strlen(input);//
//////    for (int i = 0; i < len; i++)
//////    {
//////        int a = (int)input[i];
//////        a = a - 97;
//////        count[a]++;
//////    }
//////
//////    int max = 0;
//////    for (int i = 0; i < 26; i++)
//////    {
//////        if (count[i] > count[max])
//////        {
//////            max = i;
//////        }
//////    }
//////    printf("%c\n", count[max] + 97);
//////    printf("%d\n", count[max]);
//////    return 0;
//////}
////
////#include<stdio.h>
////#include<stdlib.h>
////#include<stdbool.h>
////
////int LetNumInArr(int* arr, int num)
////{
////    int i = 0;
////    while (num)
////    {
////        arr[i] = num % 10;
////        i++;
////        num = num / 10;
////    }
////    return i;
////}
////
////bool Compare(int* arr1, int* arr2, int len, int n)
////{
////    for (int i = 0; i <= (n - len); i++)
////    {
////        int ret = memcmp(arr1 + i, arr2, sizeof(int) * len);
////        if (ret == 0)
////        {
////            return true;
////        }
////    }
////    return false;
////}
////
////int main()
////{
////    int n;
////    scanf("%d", &n);
////
////    int* arr = (int*)malloc(sizeof(int) * n);
////    if (arr == NULL)
////    {
////        printf("malloc false\n");
////        exit(-1);
////    }
////
////    for (int i = 0; i < n; i++)
////    {
////        scanf("%d", &arr[i]);
////    }
////
////    //
////
////    int* tmp = (int*)malloc(sizeof(int) * n);
////    if (tmp == NULL)
////    {
////        printf("malloc false\n");
////        exit(-1);
////    }
////    int begin = 1;
////
////    while (1)
////    {
////
////        int len = LetNumInArr(tmp, begin);
////        bool Judge = Compare(arr, tmp, len, n);
////        if (Judge == true)
////        {
////            begin++;
////        }
////        else
////        {
////            printf("%d\n", begin);
////            break;
////        }
////    }
////    return 0;
////}
//
////#include<stdio.h>
////
////int main()
////{
////	int arr[10];
////
////	printf("\n");
////
////	int a;
////	int b;
////	b = 8;
////
////
////	return 0;
////}
//
////#include<stdio.h>
////
////int main()
////{
////
////	int a;
////
////	printf("\n");
////
////	return 0;
////}
//
//#include<stdio.h>
//
//int Judge(int num)//判断日期合不合法
//{
//    int arr[12] = { 31,28,31,30,31,30,31,31,30,31,30,31 };
//
//    int year = num / 10000;
//
//    //判断是不是闰年
//    if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0))
//    {
//        arr[1]++;
//    }
//
//    int month = (num % 10000) / 100;
//    if (month > 12)
//    {
//        return 0;
//    }
//    int day = num % 1000000;
//    if (arr[month - 1] <= day)
//    {
//        return 1;
//    }
//    else
//    {
//        return 0;
//    }
//}
//
//int Judge1(int num)//判断是否回文
//{
//
//    int a = Judge2(num);
//    if (a == 0)
//    {
//        return -1;
//    }
//
//    int tmp = num;
//    int arr[8];
//    for (int i = 7; i >= 0; i--)
//    {
//        arr[i] = tmp % 10;
//        tmp /= 10;
//    }
//
//    int left = 0;
//    int right = 7;
//
//    while (left < right)
//    {
//        if (arr[left] == arr[right])
//        {
//            left++;
//            right--;
//        }
//        else
//        {
//            return -1;
//        }
//    }
//    return num;
//}
//
//int Judge2(int num)
//{
//    int a = Judge2(num);
//    if (a == 0)
//    {
//        return -1;
//    }
//    int tmp = num;
//    int arr[8];
//    for (int i = 7; i >= 0; i--)
//    {
//        arr[i] = tmp % 10;
//        tmp /= 10;
//    }
//
//    if (arr[0] != arr[1] && arr[0] == arr[2] && arr[2] == arr[5] && arr[5] == arr[7])
//    {
//        if (arr[1] == arr[3] && arr[3] == arr[4] && arr[4] == arr[6])
//        {
//            return num;
//        }
//    }
//    return -1;
//}
//
//int main()
//{
//    int N;
//    scanf("%d", &N);
//
//    int ret1 = -1;
//    int ret2 = -1;
//
//    N++;
//
//    while (1)
//    {
//        if (ret1 == -1)
//        {
//            ret1 = Judge1(N);
//        }
//        if (ret2 == -1)
//        {
//            ret2 = Judge2(N);
//        }
//
//        if (ret1 != -1 && ret2 != -1)
//        {
//            break;
//        }
//        N++;
//    }
//    printf("%d\n%d\n", ret1, ret2);
//
//    return 0;
//}

//#include<stdio.h>
//
//int main()
//{
//	int a[] = { 1,2,3,4 };
//	printf("%d\n", sizeof(a));//16
//	printf("%d\n", sizeof(a + 0));//16
//	printf("%d\n", sizeof(*a));//4
//	printf("%d\n", sizeof(a + 1));//12
//	printf("%d\n", sizeof(a[1]));//4
//	printf("%d\n", sizeof(&a));//16
//	printf("%d\n", sizeof(*&a));//4
//	printf("%d\n", sizeof(&a[0]));//16
//	printf("%d\n", sizeof(&a[0] + 1));//12
//}

//#include<stdio.h>
//
//void Swap(int* num1, int* num2)//用于交换数组中的两个数
//{
//	int tmp = *num1;
//	*num1 = *num2;
//	*num2 = tmp;
//}
//
//void Print(int* arr, int sz)
//{
//	for (int i = 0; i < sz; i++)
//	{
//		printf("%d ", arr[i]);
//	}
//	printf("\n");
//}
//
////用于快速排序  的  三数取中（即在begin、end和 (begin+end)/2之间取一个处在中间的值，这样保证在一趟排序中，key值不会是最大，也不会是最小
//int GetMidIndex(int* arr, int begin, int end)
//{
//	int mid = (begin + end) / 2;
//	if (arr[begin] > arr[mid])
//	{
//		if (arr[begin] > arr[end])
//		{
//			return arr[mid] > arr[end] ? mid : end;
//		}
//	}
//	else if (arr[mid] > arr[end])
//	{
//		if (arr[mid] > arr[begin])
//		{
//			return arr[end] > arr[begin] ? end : begin;
//		}
//	}
//	else
//	{
//		return arr[begin] > arr[mid] ? begin : mid;
//	}
//	//返回的是 中间的数 的下标
//}
//
////一趟快速排序，左右指针法，其中begin为待排数组的第一个元素，end为数组的最后一个元素
//int PartSort1(int* arr, int begin, int end)
//{
//
//	int mid = GetMidIndex(arr, begin, end);
//	Swap(&arr[mid], &arr[end]);
//
//	int key = arr[end];//取最后一个数作为基准值key
//
//	int left = begin;//左指针起始位置
//	int right = end;//右指针起始位置
//
//	while (left < right)//当左指针在右指针的左边，即区间还有效
//	{
//		while (left < right && arr[left] <= key)//左指针往右找大
//		{
//			left++;
//		}
//
//		while (left < right && arr[right] >= key)//右指针往左找小
//		{
//			right--;
//		}
//
//		Swap(&arr[left], &arr[right]);//交换左右指针的值
//
//	}
//
//	Swap(&arr[left], &arr[end]);//将基准值key换到中间
//
//	return left;//返回中间的位置
//}
//
//int PartSort2(int* arr, int begin, int end)//挖坑法
//{
//	int key = arr[end];//选最后一个元素作为基准值key
//
//	int left = begin;//左指针指向第一个元素
//	int right = end;//右指针指向最后一个元素
//
//
//	while (left < right)
//	{
//		while (left < right && arr[left] <= key)//左指针往右找大填坑
//		{
//			left++;
//		}
//
//		arr[right] = arr[left];
//
//		while (left < right && arr[right] >= key)//右指针往右找小填坑
//		{
//			right--;
//		}
//
//		arr[left] = arr[right];
//
//	}
//
//	arr[left] = key;
//
//	return left;
//}
//
//int PartSort3(int* arr, int begin, int end)//前后指针法
//{
//	int key = arr[end];
//
//	int prev = begin - 1;//前指针
//	int tail = begin;//后指针
//
//	while (tail < end)
//	{
//		if (arr[tail] < key)
//		{
//			prev++;
//			Swap(&arr[prev], &arr[tail]);
//		}
//		tail++;
//	}
//
//	prev++;
//	Swap(&arr[prev], &arr[tail]);
//
//	return prev;
//}
//
//void QuickSort(int* arr, int begin,int end)//快速排序递归实现
//{
//	if (begin >= end)//当待排区间不合法时，返回
//	{
//		return;
//	}
//
//	int div = PartSort1(arr, begin, end);
//	//一趟快速排序完成后[begin,div-1] div [div+1,end]  div为已经排完的位置，后面只需要排[begin,div-1] 和 [div+1,end]区间即可
//
//	//Print(arr, end - begin + 1);
//
//	QuickSort(arr, begin, div - 1);//排[begin,div-1]区间
//	QuickSort(arr, div + 1, end);//排[div+1,end]区间
//}
//
//void QuickSortNonR(int* arr, int begin, int end)//快速排序非递归实现
//{
//	int Stack[20] = { 0 };//创建一个栈区
//	int size = 0;//栈区中的元素个数，同时能作为下标来用
//
//	//将区间[begin,end]入栈，注意！！！  先入右边，再入左边
//	Stack[size] = end;
//	size++;
//
//	Stack[size] = begin;
//	size++;
//
//	//当栈不为空时
//	while (size > 0)
//	{
//		//将左右出栈
//		int left = Stack[size - 1];
//		size--;
//
//		int right = Stack[size - 1];
//		size--;
//
//		if (left < right)
//		{
//			int div = PartSort1(arr, left, right);
//			//一趟排完后，区间分为[left,div-1] div [div+1,right]
//			//将[left,div-1]  [div+1,right]入栈
//			Stack[size] = right;
//			size++;
//
//			Stack[size] = div + 1;
//			size++;
//
//			Stack[size] = div - 1;
//			size++;
//
//			Stack[size] = left;
//			size++;
//		}
//	}
//}
//
//int main()
//{
//	int arr1[] = { 4,5,8,6,2,1,596,14,6 };
//	int arr2[] = { 48,45,1,23,60,14 };
//
//	Print(arr1, sizeof(arr1) / sizeof(int));
//	QuickSort(arr1, 0, sizeof(arr1) / sizeof(int) - 1);
//	Print(arr1, sizeof(arr1) / sizeof(int));
//
//	Print(arr2, sizeof(arr2) / sizeof(int));
//	QuickSortNonR(arr2, 0, sizeof(arr2) / sizeof(int) - 1);
//	Print(arr2, sizeof(arr2) / sizeof(int));
//
//	return 0;
//}

//#include <stdio.h>
//int main()
//{
//	char a = -1;
//	signed char b = -1;
//	unsigned char c = -1;
//	printf("a=%d,b=%d,c=%d", a, b, c);
//	return 0;
//}

//#include <stdio.h>
//int main()
//{
//	char a = -128;
//	printf("%u\n", a);
//	return 0;
//}

//#include <stdio.h>
//int main()
//{
//	char a = 128;
//	printf("%u\n", a);
//	return 0;
//}
//
//#include <stdio.h>
//union Un1
//{
//	char c[5];
//	int i;	
//};
//union Un2
//{
//	short c[7];
//	int i;
//};
//int main()
//{
//	//下⾯输出的结果是什么？
//	printf("%d\n", sizeof(union Un1));
//	printf("%d\n", sizeof(union Un2));
//	return 0;
//}

//#include<stdio.h>
//#include<ctype.h>
//
//int main()
//{
//
//	int c;
//	while ( (c = fgetc(stdin)) != EOF)
//	{
//		c = toupper(c);
//		fputc(c, stdout);
//	}
//
//	return 0;
//}

//#include<stdio.h>
//#include<stdlib.h>
//
//void Print(int* arr, int sz)
//{
//	for (int i = 0; i < sz; i++)
//	{
//		printf("%d ", arr[i]);
//	}
//	printf("\n");
//}
//
////单趟归并排序
//void MergeArr(int* arr, int* tmp, int left, int mid, int right)
//{
//	int begin1 = left;
//	int end1 = mid;
//	int begin2 = mid + 1;
//	int end2 = right;
//
//	int i = begin1;
//
//	while (begin1 <= end1 && begin2 <= end2)
//	{
//		if (arr[begin1] < arr[begin2])
//		{
//			tmp[i] = arr[begin1];
//			i++;
//			begin1++;
//		}
//		else
//		{
//			tmp[i] = arr[begin2];
//			i++;
//			begin2++;
//		}
//	}
//
//	while (begin1 <= end1)
//	{
//		tmp[i] = arr[begin1];
//		i++;
//		begin1++;
//	}
//
//	while (begin2 <= end2)
//	{
//		tmp[i] = arr[begin2];
//		i++;
//		begin2++;
//	}
//
//	//Print(tmp, 8);
//	for (int i = left; i <= right; i++)
//	{
//		arr[i] = tmp[i];
//	}
//
//}
//
//void MergePartSort(int* arr, int*tmp, int begin, int end)//归并排序分区间和归并
//{
//
//	if (begin >= end)
//	{
//		return;
//	}
//
//	//分区间
//	int mid = (begin + end) / 2;
//
//	MergePartSort(arr, tmp, begin, mid);
//	MergePartSort(arr, tmp, mid + 1, end);
//
//	//归并
//
//	MergeArr(arr, tmp, begin, mid, end);
//}
//
//void MergeSort(int* arr, int begin, int end)//归并排序
//{
//	int* tmp = (int*)malloc(sizeof(int) * (end - begin + 1));
//	if (tmp == NULL)
//	{
//		printf("malloc false\n");
//		exit(-1);
//	}
//
//	MergePartSort(arr, tmp, begin, end);
//
//	free(tmp);
//}
//
//void MergeSortNonR(int* arr, int begin, int end)//归并排序非递归实现
//{
//	int* tmp = (int*)malloc(sizeof(int) * (end - begin + 1));
//	if (tmp == NULL)
//	{
//		printf("malloc false\n");
//		exit(-1);
//	}
//
//	int gap = 1;
//
//	while (gap < (end - begin + 1))
//	{
//		for (int i = 0; i <= end; i = i + 2 * gap)
//		{
//			int left = i;
//			int right = i + 2 * gap - 1;
//			int mid = (right + left) / 2;
//			if (right > end)
//			{
//				right = end;
//			}
//
//			MergeArr(arr, tmp, left, mid, right);
//		}
//		//Print(arr, 12);
//
//		gap = gap * 2;
//	}
//
//}
//
//int main()
//{
//	//int arr[] = { 1,3,5,7,2,4,6,8 };
//	int arr[] = { 1,5,2,10,3,4,8,9,5,3,1,5 };
//	//int arr[] = { 1 };
//	//int arr[] = { 15,863,475,123,94, };
//	
//	//Print(arr, sizeof(arr) / sizeof(int));
//	//MergePartSort(arr, 0, 3, 7);
//	//Print(arr, sizeof(arr) / sizeof(int));
//
//	//MergeSort(arr, 0, sizeof(arr) / sizeof(int) - 1);
//
//	Print(arr, sizeof(arr) / sizeof(int));
//	MergeSortNonR(arr, 0, sizeof(arr) / sizeof(int) - 1);
//
//	Print(arr, sizeof(arr) / sizeof(int));
//
//	return 0;
//}


//#include<stdio.h>
//
//typedef int(*p_fun)(int, int);
//
//int Add(int x, int y)
//{
//	return x + y;
//}
//
//int main()
//{
//	printf("%p\n", Add);
//	printf("%p\n", &Add);
//
//	int ret1 = Add(1, 2);
//	printf("%d\n", ret1);
//
//	int (*pAdd)(int, int) = &Add;
//
//	p_fun pAdd2= &Add;
//
//
//	int ret2 = pAdd(3, 5);
//	printf("%d\n", ret2);
//
//	int ret3 = pAdd2(3, 5);
//	printf("%d\n", ret3);
//
//
//	return 0;
//}
//
//#include<stdio.h>
//
//typedef int(*p_fun)(int, int);//使用typedef关键字简化代码长度
//
//int Add(int x, int y)
//{
//	return x + y;
//}
//
//int main()
//{
//	int ret1 = Add(1, 2);
//	printf("%d\n", ret1);//常规用法
//
//	int (*pAdd)(int, int) = &Add;//使用函数指针的用法
//	int ret2 = pAdd(2, 3);
//	printf("%d\n", ret2);
//
//	p_fun pAdd2 = &Add;//使用typedef的用法。
//	int ret3 = pAdd2(3, 4);
//	printf("%d\n", ret3);
//
//	return 0;
//}


//#include<stdio.h>
//
//int Add(int x, int y)
//{
//	return x + y;
//}
//
//int Sub(int x, int y)
//{
//	return x - y;
//}
//
//int Mul(int x, int y)
//{
//	return x * y;
//}
//
//int Div(int x, int y)
//{
//	return x / y;
//}
//
//void menu()
//{
//	printf("		1.加法  2.减法	 \n");
//	printf("		3.乘法  4.除法	 \n");
//	printf("		  0.退出程序  	 \n");
//}
//
//int main()
//{
//	int input = 0;
//	int x, y;
//	do
//	{
//		menu();
//		printf("请输入操作：");
//		scanf("%d", &input);
//
//		switch (input)
//		{
//		case 1:
//			printf("请输入两个数：");
//			scanf("%d %d", &x, &y);
//			int ret = Add(x, y);
//			printf("%d\n", ret);
//			break;
//		case 2:
//			printf("请输入两个数：");
//			scanf("%d %d", &x, &y);
//			ret = Sub(x, y);
//			printf("%d\n", ret);
//			break;
//		case 3:
//			printf("请输入两个数：");
//			scanf("%d %d", &x, &y);
//			ret = Mul(x, y);
//			printf("%d\n", ret);
//			break;
//		case 4:
//			printf("请输入两个数：");
//			scanf("%d %d", &x, &y);
//			ret = Div(x, y);
//			printf("%d\n", ret);
//			break;
//		case 0:
//			break;
//		default:
//			printf("输入错误，请重新输入\n");
//			continue;
//		}
//
//	} while (input);
//	return 0;
//}


//#include<stdio.h>
//
//int Add(int x, int y)
//{
//	return x + y;
//}
//
//int Sub(int x, int y)
//{
//	return x - y;
//}
//
//int Mul(int x, int y)
//{
//	return x * y;
//}
//
//int Div(int x, int y)
//{
//	return x / y;
//}
//
//void menu()
//{
//	printf("		1.加法  2.减法	 \n");
//	printf("		3.乘法  4.除法	 \n");
//	printf("		  0.退出程序  	 \n");
//}
//
//int main()
//{
//	int (*parr[4])(int, int) = { &Add,&Sub,&Mul,&Div };
//	int input = 0;
//	do
//	{
//		menu();
//		printf("请输入你的操作：");
//		scanf("%d", &input);
//
//		if (input == 0)
//		{
//			break;
//		}
//		else if (input >= 1 && input <= 4)
//		{
//			int x, y;
//			printf("请输入两个数：");
//			scanf("%d %d", &x, &y);
//			int ret = parr[input - 1](x, y);
//			printf("%d\n", ret);
//		}
//		else
//		{
//			printf("输入错误，请重新输入\n");
//		}
//
//	} while (input);
//
//	return 0;
//}
//
//#include<stdio.h>
//
//int Compare(void* p1, void* p2)//用于qsort函数的比较函数
//{
//	return *(int*)p1 - *(int*)p2;
//}
//
//void Print(int* parr, int sz)//打印数组
//{
//	for (int i = 0; i < sz; i++)
//	{
//		printf("%d ", parr[i]);
//	}
//	printf("\n");
//}
//
//int main()
//{
//	int arr[] = { 10,8,6,47,52,10,23,69,74 };
//	Print(arr, sizeof(arr) / sizeof(arr[0]));
//
//	qsort(arr, sizeof(arr) / sizeof(arr[0]), sizeof(arr[0]), Compare);//使用qsort函数对数组进行排序
//	Print(arr, sizeof(arr) / sizeof(arr[0]));
//
//	return 0;
//}








//#include<stdio.h>
//
//typedef struct Stu
//{
//	char name[20];
//	int age;
//}Stu;
//
//int Compare1(void* p1, void* p2)
//{
//	return (*(Stu*)p1).age - (*(Stu*)p2).age;
//}
//
//int Compare2(void* p1, void* p2)
//{
//	return strcmp((*(Stu*)p1).name, (*(Stu*)p2).name);
//}
//
//int main()
//{
//	Stu arr[] = { {"张三",18}, {"李四",20},{"王五",19} };
//	for (int i = 0; i < sizeof(arr) / sizeof(arr[0]); i++)
//	{
//		printf("%s %d\n", arr[i].name, arr[i].age);
//	}
//
//	qsort(arr, sizeof(arr) / sizeof(arr[0]), sizeof(arr[0]), Compare2);
//
//	for (int i = 0; i < sizeof(arr) / sizeof(arr[0]); i++)
//	{
//		printf("%s %d\n", arr[i].name, arr[i].age);
//	}
//
//	return 0;
//}








//#include<stdio.h>
//
//typedef struct Stu
//{
//	char name[20];
//	int age;
//}Stu;
//
//void Swap(void* p1, void* p2, int sz)//交换函数，一个字节一个字节的交换
//{
//	for (int i = 0; i < sz; i++)
//	{
//		char tmp = *((char*)p1 + i);
//		*((char*)p1 + i) = *((char*)p2 + i);
//		*((char*)p2 + i) = tmp;
//	}
//}
//
//void Bubble_Sort(void* arr, int num, int sz, int (*Compare)(void*, void*))//使用冒泡排序模拟回调函数
//{	
//	for (int i = num; i > 0; i--)
//	{
//		for (int j = 0; j < i - 1; j++)
//		{
//			if (Compare((char*)(arr)+j * sz, (char*)(arr)+(j + 1) * sz)>0)
//			{
//				Swap((char*)(arr)+j * sz, (char*)(arr)+(j + 1) * sz, sz);
//			}
//		}
//	}
//}
//
//int Compare1(void* p1, void* p2)//按年龄来排序
//{
//	return ((Stu*)p1)->age - ((Stu*)p1)->age;
//}
//
//int Compare2(void* p1, void* p2)//按名字来排序
//{
//	return strcmp(((Stu*)p1)->name, ((Stu*)p2)->name);
//}
//
//int main()
//{
//	Stu arr[] = { {"张三",18},{"李四",19},{"王五",20} };
//	int num = sizeof(arr) / sizeof(arr[0]);
//
//	for (int i = 0; i < num; i++)
//	{
//		printf("%s %d\n", arr[i].name, arr[i].age);
//	}
//
//	Bubble_Sort(arr, num, sizeof(arr[0]), Compare2);
//
//	for (int i = 0; i < num; i++)
//	{
//		printf("%s %d\n", arr[i].name, arr[i].age);
//	}
//
//	return 0;
//}

//
//#include<stdio.h>
//
//typedef struct Stu
//{
//	char name[20];
//	int age;
//}Stu;
//
//int  main()
//{
//
//	Stu a = { "张三",18 };
//
//	printf("%s %d\n", a.name, a.age);
//
//	char tmp[100];
//
//	sprintf(tmp, "%s %d", a.name, a.age);
//
//	printf("%s\n", tmp);
//
//	return 0;
//}


//#include<stdio.h>
//int main()
//{
//	FILE* pf = fopen("test.txt", "w");//以写的形式打开文件
//	if (pf == NULL)//检查文件是否打开成功
//	{
//		printf("打开文件失败\n");
//		exit(-1);
//	}
//
//	char arr[20] = "hello world";
//	fputs(arr, pf);
//
//	fclose(pf);//关闭文件
//	return 0;
//}


//#include<stdio.h>
//int main()
//{
//	FILE* pf = fopen("test.txt", "r");//以读的形式打开文件
//	if (pf == NULL)
//	{
//		printf("打开文件失败\n");
//		exit(-1);
//	}
//	char arr[20];
//	fgets(arr, 100, pf);
//	printf("%s\n", arr);
//
//	fclose(pf);
//	return 0;
//}


//
//#include<stdio.h>
//
//typedef struct Stu
//{
//	char name[20];
//	int age;
//}Stu;
//
//int main()
//{
//	Stu arr[] = { {"张三",18},{"李四",20} };
//	FILE* pf = fopen("test.txt", "w");//以写的形式打开文件
//	if (pf == NULL)//判断文件是否打开成功
//	{
//		printf("打开文件失败\n");
//		exit(-1);
//	}
//
//	int sz = sizeof(arr) / sizeof(arr[0]);//arr数组的元素个数
//	for (int i = 0; i < sz; i++)
//	{
//		fprintf(pf, "%s %d\n", arr[i].name, arr[i].age);//把Stu数组中的数据写入到外存中
//	}
//
//	fclose(pf);//关闭文件
//	return 0;
//}

//#include<stdio.h>
//
//typedef struct Stu
//{
//	char name[20];
//	int age;
//}Stu;
//
//int main()
//{
//	FILE* pf = fopen("test.txt", "r");//以读的形式打开文件
//	if (pf == NULL)
//	{
//		printf("打开文件失败\n");
//		exit(-1);
//	}
//
//	Stu arr[2];
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	for (int i = 0; i < sz; i++)//将文件中的信息读入到arr数组中
//	{
//		fscanf(pf, "%s %d", &arr[i].name, &arr[i].age);
//	}
//
//	for (int i = 0; i < sz; i++)//输出arr数组
//	{
//		printf("%s %d\n", arr[i].name, arr[i].age);
//	}
//
//	fclose(pf);//关闭文件
//	return 0;
//}

//#include<stdio.h>
//
//int main()
//{
//	FILE* pf1 = fopen("test.txt", "w");//使用fopen函数来打开文件
//	if (pf1 == NULL)
//	{
//		printf("打开文件失败\n");
//		exit(-1);	
//	}
//	fputs("hello world", pf1);
//	fclose(pf1);//使用fclose函数来关闭文件
//
//	FILE* pf2 = fopen("test.txt", "r");
//	if (pf2 == NULL)
//	{
//		printf("打开文件失败\n");
//		exit(-1);
//	}
//
//	char arr[20];
//	fgets(arr, 100, pf2);
//	printf("%s\n", arr);
//
//	fclose(pf2);
//
//	return 0;
//}

//#include<stdio.h>
//
//int main()
//{
//	FILE* pf = fopen("test.txt", "w");
//	if (pf == NULL)
//	{
//		printf("打开文件失败\n");
//		exit(-1);
//	}
//
//	fputs("hello world", pf);
//
//	fseek(pf, 3, SEEK_SET);
//	fputs("aaa", pf);
//
//	fclose(pf);
//	return 0;
//}

//#include<stdio.h>
//
//int main()
//{
//	FILE* pf = fopen("test.txt", "w");
//	if (pf == NULL)
//	{
//		printf("打开文件失败\n");
//		exit(-1);
//	}
//
//	fputs("hello world", pf);
//	int ret = ftell(pf);
//	printf("%d\n", ret);
//
//	fclose(pf);
//	return 0;
//}

//#include<stdio.h>
//
//int main()
//{
//	char arr[] = { "张三 18" };
//	printf("%s\n", arr);
//
//	char name[10];
//	int age;
//
//	sscanf(arr, "%s %d", name, &age);
//	printf("%s %d", name, age);
//
//	return 0;
//}

//#include<stdio.h>
//
//int main()
//{
//	FILE* pf = fopen("test.txt", "w");
//	if (pf == NULL)
//	{
//		printf("open fail\n");
//		exit(-1);
//	}
//	
//	return 0;
//}

//#include<stdio.h>
//
//union UN
//{
//	short a[7];
//	int b;
//};
//
//int main()
//{
//	union UN un;
//	printf("%d\n", sizeof(un));
//	return 0;
//}

//#include<stdio.h>
//
//struct A
//{
//	char i;
//	int a;
//	long long b;
//};
//
//int main()
//{
//	printf("%d\n", sizeof(struct A));
//	return 0;
//}

//#include<stdio.h>
//
//int Count()
//{
//	static int a = 0;
//	a++;
//	printf("%d\n", a);
//}
//
//int main()
//{
//	for (int i = 0; i < 10; i++)
//	{
//		Count();
//	}
//	return 0;
//}

//#include<stdio.h>
//
//int Judge(char* arr, int len)
//{
//    int count = 0;
//    int tmp[26] = { 0 };
//    for (int i = 0; i < len; i++)
//    {
//        tmp[arr[i] - 97]++;
//    }
//
//    for (int i = 0; i < 26; i++)
//    {
//        if (tmp[i] != 0)
//        {
//            count++;
//        }
//    }
//    return count;
//}
//
//int main()
//{
//     请在此输入您的代码
//    输入字符串
//    char arr[50001];
//    scanf("%s", arr);
//
//    int len = strlen(arr);
//
//    int ret = 0;
//
//    for (int input = 1; input <= len; input++)
//    {
//        int input2 = input;
//        for (int i = 0; i <= len - input; i++)
//        {
//            int j = i;
//            char arr2[50001];
//            int k = 0;
//            while (input > 0)
//            {
//                arr2[k] = arr[j];
//                j++;
//                k++;
//                input--;
//            }
//            input = input2;
//            ret = Judge(arr2, input2) + ret;
//        }
//    }
//    printf("%d", ret);
//
//    return 0;
//}
	

#include <stdio.h>
//#include <stdlib.h>
//
//int main()
//{
//    int N;
//    scanf("%d", &N);
//
//    int arr1[100000] = { 0 }；
//        int arr2[100000] = { 0 }；
//        int arr3[100000] = { 0 }；
//
//        for (int i = 0; i < N; i++)
//        {
//            scanf("%d", arr1[i]);
//        }
//
//    for (int i = 0; i < N; i++)
//    {
//        scanf("%d", arr2[i]);
//    }
//
//    for (int i = 0; i < N; i++)
//    {
//        scanf("%d", arr3[i]);
//    }
//
//    int count = 0;//计数器
//
//    for (int i = 0; i < N; i++)
//    {
//        for (int j = 0; j < N;; j++)
//        {
//            if (arr1[i] < arr2[j])
//            {
//                for (int k = 0; k < N; k++)
//                {
//                    if (arr2[j] < arr3[k])
//                    {
//                        count++;
//                    }
//                }
//            }
//        }
//    }
//
//    printf("%d\n", count);
//
//    return 0;
//}

//#include <stdio.h>
//#include <stdlib.h>
//
//int main()
//{
//    int N;
//    scanf("%d", &N);
//
//    int arr1[1000] = { 0 };
//    int arr2[1000] = { 0 };
//    int arr3[1000] = { 0 };
//
//    for (int i = 0; i < N; i++)
//    {
//        scanf("%d", &arr1[i]);
//    }
//
//    for (int i = 0; i < N; i++)
//    {
//        scanf("%d", &arr2[i]);
//    }
//
//    for (int i = 0; i < N; i++)
//    {
//        scanf("%d", &arr3[i]);
//    }
//
//    int count = 0;//计数器
//
//    for (int i = 0; i < N; i++)
//    {
//        for (int j = 0; j < N; j++)
//        {
//            if (arr1[i] < arr2[j])
//            {
//                for (int k = 0; k < N; k++)
//                {
//                    if (arr2[j] < arr3[k])
//                    {
//                        count++;
//                    }
//                }
//            }
//        }
//    }
//
//    printf("%d\n", count);
//
//    return 0;
//}

#include<stdio.h>
#include<stdbool.h>
#include<math.h>

bool Judge(int x)
{
    for (int i = 2; i <= sqrt(x); i++)
    {
        if (x % i == 0)
        {
            return false;
        }
    }
    return true;
}


int main()
{
    int T;
    scanf("%d", &T);

    for (int i = 0; i < T; i++)
    {
        int input;
        scanf("%d", &input);

        int count = 0;
        for (int j = 2; j <= input; j++)
        {
            bool ret = Judge(j);
            if (ret == true)
            {
                count++;
            }
        }
        printf("%d\n", count);
    }

    return 0;
}